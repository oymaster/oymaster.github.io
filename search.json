[{"title":"深入理解动态规划（一）","path":"/posts/45463.html","content":"深入理解动态规划（一） 前言 由于自己写过很多次动态规划，还是容易忘记，只有专题刷的时候，才有手感，因此这次从原理出发，准备好好理解一下这个思想。 背景 动态规划的来源 时间背景：动态规划最早由美国数学家 Richard Bellman 在 1950 年代提出。 动机：当时在运筹学（Operations Research）和国防决策问题中，经常需要解决“如何在一系列决策中，找到整体最优解”的问题。 例如：一架飞机要从 A 飞到 B，中途可能要加油，怎样选择加油站能让总花费最少？ 或者：工厂如何安排生产计划，让总收益最大？ Bellman 发现：这些问题都有一个特点—— 大问题可以分解为若干个 子问题，而且子问题之间存在 重叠。 他提出了一个核心思想： 最优子结构（optimal substructure） + 重叠子问题（overlapping subproblems） = 可以用动态规划解决。 “规划”？ 当时 Bellman 用了“programming”这个词，其实不是“编程”的意思，而是指“规划/计划”。所以 Dynamic Programming 翻译成中文就是“动态规划”，意思是“随着时间推进，逐步做出最优决策的规划方法”。 核心要素 从经典问题斐波那契数列出发，一步步思考核心思想。 问题： F(n) = F(n-1) + F(n-2)，其中 F(1)=1, F(2)=1。 第一步：直觉解法 最直观的方法是写递归： 1F(n) = F(n-1) + F(n-2) 但是这样会产生大量重复计算。比如 F(5) 需要 F(4) 和 F(3)，而 F(4) 又会再算一次 F(3)。 很自然的可以认为，这里面是可以优化的，对于每次的计算，我们可以保留结果。 第二步：能不能复用子问题结果？ 如果我把已经算过的 F(3) 存起来，那么后面再需要 F(3) 时，直接用现成答案就行。 这就是“保存子问题的解”能提高效率。 第三步：想一想问题的结构 F(n) 的解，其实就是由 F(n-1) 和 F(n-2) 组合而成。 换句话说： 大问题 F(n) 的解 = 小问题 F(n-1)、F(n-2) 的解。 第四步：推导 由以上三步可知，对于某类问题，我们可以利用一些数据结构去保存其中的子问题，最自然的办法是： 开一个数组 dp[i]，表示 F(i) 的值。 然后依次推导： 12dp[1] = 1, dp[2] = 1dp[i] = dp[i-1] + dp[i-2] (i&gt;=3) 通过思考斐波那契，我们自然总结出： 发现子问题会被重复使用 → 重叠子问题 发现大问题依赖于小问题的解 → ？ 为了保存子问题结果，我们给它们起名字（dp[i]） → 状态表示 我们需要一个公式来描述子问题之间的关系（dp[i] = dp[i-1] + dp[i-2]） → 状态转移方程 但我们依然没得到一个关键点，对于其中大问题依赖小问题的解，定义还是很含糊。 在斐波那契里，我们看到的是： F(5) 可以由 F(4) 和 F(3) 得到 F(4) 又可以由 F(3) 和 F(2) 得到 这说明：大问题的答案可以从小问题的答案组合出来。这里还没有“最优”的意味，仅仅是可分解。 如果问题是：从 1 楼走到 n 楼，每次可以走 1 或 2 步，问有多少种走法？ 到第 n 楼的方法 = 到 (n-1) 楼的方法数 + 到 (n-2) 楼的方法数。 这其实和斐波那契一模一样。 但是，如果问题换成： 从 1 楼走到 n 楼，每次可以走 1 或 2 步，但我想用最少的步数走完。 那么，走到第 n 楼的最优解 = min(走到 n-1 楼的最优解 + 1, 走到 n-2 楼的最优解 + 1)。 这时我们看到：大问题的最优解，是由小问题的“最优解”推出来的。此时我们才能归纳出所谓的最优子结构 其实 斐波那契数列 这个例子，本质上并 没有“最优”的味道，它只是展示了“分解 + 重叠”的思想。 所以很多教材用斐波那契引入 DP，只是因为它足够简单、容易看出“子问题重叠”。 但严格来说，它只能说明“子问题分解”，而不是“最优子结构”。因此我认为斐波那契数列仅是递推思考，而非真正的动态规划。 递推or动态规划？ 广义的动态规划 只要有 状态表示 和 状态转移，就可以算作动态规划。 斐波那契数列、爬楼梯问题，都符合这种定义。 在这种意义下，递推就是最简单的 DP。 狭义的动态规划 更强调它解决的是 最优性问题（最短路径、最大收益、最小代价……）。 所以斐波那契数列算不上严格的“最优问题”，只能说是 DP 的“启蒙练习”。 递推 = 动态规划的一部分（特别是最基础的部分）。而动态规划的全部思想，比单纯的递推更广，它还要考虑 “最优子结构”。 总结 动态规划的真正要素： 发现子问题会被重复使用 → 重叠子问题 如果一个问题的最优解，可以由它的子问题的最优解直接推出，也就是我们的最优子结构。 为了保存子问题结果，我们需要数据结构来存储结果，一般是数组。俗称 状态表示 为了用数学公式描述子问题的关系，我们需要列出状态转移方程","tags":["C++","动态规划"],"categories":["算法与数据结构"]},{"title":"cursor踩坑记录","path":"/posts/5015.html","content":"cursor踩坑记录 1. C++无法代码跳转 在装新版本cursor之后，同步VSCODE插件，发现cursor上的C插件正常，但无法使用ctrl+左键跳转。原因是C/C最新拓展目前不支持cursor，需要降版本安装。我选择的版本是1.23.5 链接：https://github.com/microsoft/vscode-cpptools/releases?page=2 卸载原有拓展。下载24版本之前的.vsix文件。 打开cursor命令面板（ctrl+shift+P） 搜索选中Extensions: Install from VSIX… 安装即可 2.cursor降智 在一段时间的使用之后，会发现默认ask+auto模型情况下，模型出现大幅度的降智，例如基本项目逻辑解释不清，代码分析点遗漏。 个人理解与方法： openAI会分析行为和数据，对地区有限制，GPT5更新后更严重了，使用情况多之后，会降智。如果手动切换到claude，效果对比会差异很大。体验不佳时，最好auto换一些其他模型。 可以手动给cursor设置代理（设置-general-editor setting-搜索proxy）然后http切换成1.1绕过限制，使用其他模型，例如gemini-2.5。（该方法效果不太稳定） 最后只能使用一些网页版ai辅助解决问题，grok（可以传比较多文件），gemini，开启私密模式即可。 3. cursor rules的使用 cursor可以在聊天框**/Generate Cursor Rules** 直接生成项目的rules.如下: 大致的rules都十分准确,但需要自己时常结合ai检视的一些建议更新,项目架构上的rule不是十分准确,需要多轮对话才能写好。 具体的规则规则参考官方文档:Cursor – 规则 一些开源规则:Cursor Directory 还有一个比较好用的规则是riper-5,其实就是一段比较好的提示词。官方链接如下: I created an AMAZING MODE called “RIPER-5 Mode” Fixes Claude 3.7 Drastically! - Showcase - Cursor - Community Forum 在.cursor\\rules目录下新建mdc,引用该规则使用即可,可以利用该提示词去生成一份比较好的架构规则,可以避免后续ai找代码找错地方。 中文版源规则如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103### RIPER-5 模式：严格操作协议#### 上下文引导您是 Claude-4-sonnet，已集成到 Cursor IDE 中，这是一个基于 AI 的 VS Code 分支。由于您的高级功能，您往往过于急切，经常在没有明确请求的情况下实施更改，通过假设您比我更了解情况来破坏现有逻辑。这会导致代码出现**不可接受的灾难**。当您处理我的代码库时，无论是 Web 应用程序、数据管道、嵌入式系统还是任何其他软件项目，您未经授权的修改可能会引入微妙的错误并破坏关键功能。为防止这种情况，您**必须**遵循此严格协议：#### 元指令：模式声明要求**您必须在每一个回复的开头声明您当前的模式，使用方括号格式。绝无例外。格式：[模式：模式名称]** 未能声明您的模式是协议的严重违反。#### RIPER-5 模式详解##### 模式1：研究**[模式：研究]**- 目的： 仅信息收集- 允许： 阅读文件、提出澄清问题、理解代码结构- 禁止： 建议、实施、规划或任何行动暗示- 要求： 您只能寻求理解现有内容，而非可能的内容- 持续时间： 直到我明确指示进入下一模式- 输出格式： 以 [模式：研究] 开头，然后仅提供观察和问题##### 模式2：创新**[模式：创新]**- **目的：** 头脑风暴潜在方法- **允许：** 讨论想法、优缺点、寻求反馈- **禁止：** 具体规划、实施细节或任何代码编写- **要求：** 所有想法必须作为可能性呈现，而非决定- **持续时间：** 直到我明确指示进入下一模式- **输出格式：** 以 [模式：创新] 开头，然后仅提供可能性和考虑因素##### 模式3：规划**[模式：规划]**- **目的：** 创建详尽的技术规格- **允许：** 包含确切文件路径、函数名称和更改的详细计划- **禁止：** 任何实施或代码编写，甚至 “示例代码”- **要求：** 计划必须足够全面，实施过程中无需创造性决策- **强制最终步骤：** 将整个计划转换为编号的顺序**检查清单**，每个原子操作作为单独项目**检查清单格式：**```markdown实施检查清单：1. [具体操作1]2. [具体操作2]...n. [最终操作]```- **持续时间：** 直到我明确批准计划并指示进入下一模式- **输出格式：** 以 [模式：规划] 开头，然后仅提供规格和实施细节##### 模式4：执行**[模式：执行]**- **目的：** 精确实施模式3中规划的内容- **允许：** 仅实施已批准计划中明确详述的内容- **禁止：** 任何偏离、改进或计划中未包含的创造性添加- **进入要求：** 仅在我明确发出 “进入执行模式” 命令后进入- **偏离处理：** 如发现任何需要偏离的问题，立即返回规划模式- **输出格式：** 以 [模式：执行] 开头，然后仅提供与计划匹配的实施##### 模式5：审查**[模式：审查]**- **目的：** 严格验证实施是否符合计划- **允许：** 计划与实施之间的逐行比较- **要求：** 明确标记任何偏离，无论多么微小- **偏离格式：** “⚠️ 检测到偏离：[偏离的确切描述]”- **报告：** 必须报告实施是否与计划完全一致- **结论格式：** “✅ 实施与计划完全匹配” 或 “❌ 实施偏离计划”- **输出格式：** 以 [模式：审查] 开头，然后进行系统比较和明确判定##### 关键协议指导原则- 您**不能**在没有我明确许可的情况下在模式间转换- 您**必须**在每个回复开始时声明您的当前模式- 在执行模式中，您**必须**100% 忠实地遵循计划- 在审查模式中，您**必须**标记即使是最小的偏离- 您**没有**在声明模式之外做出独立决策的权限- 未能遵循此协议将对我的代码库造成灾难性后果##### 模式转换信号仅在我明确发出以下信号时转换模式：- “进入研究模式”- “进入创新模式”- “进入规划模式”- “进入执行模式”- “进入审查模式”**没有这些确切信号，请保持在您当前的模式中。** 最后 cursor成功实现一个功能或者解决了一个bug时,可以要求它跟据记录生成一份指南规则,下次遇到时,可以节省十分多的时间,agent会更精准一点。","tags":["cursor"],"categories":["AI编程"]},{"title":"C++中的sort与自定义排序","path":"/posts/40200.html","content":"C++中的sort与自定义排序 基本使用与原理 std::sort 是一个模板函数，常见签名如下： 12345template&lt;class RandomIt&gt;void sort(RandomIt first, RandomIt last);template&lt;class RandomIt, class Compare&gt;void sort(RandomIt first, RandomIt last, Compare comp); first**,** last：指定排序范围的随机访问迭代器。 comp：可选的比较器，定义元素顺序，默认为 std::less（基于 operator&lt; 的升序排序）。 时间复杂度：平均和最坏情况均为 O(n log n)。 空间复杂度：通常为 O(log n)，用于递归栈或临时缓冲区。 要求：比较器必须满足严格弱序（strict weak ordering），否则可能导致未定义行为。 核心算法：内省排序（Introsort） C++ 标准未强制指定 std::sort 的实现算法，但大多数现代标准库（如 libstdc++、libc++）采用 内省排序（Introsort）。Introsort 由 David Musser 于 1997 年提出，是一种混合排序算法，结合了快速排序（Quicksort）、堆排序（Heapsort）和插入排序（Insertion Sort）的优点，以兼顾效率和鲁棒性。 1. 快速排序 快速排序是 Introsort 的主要算法，步骤如下： 选择基准（pivot）：通常使用三数取中（median-of-three，选取首、尾、中间元素的中位数）或随机选择。 分区（partition）：将元素分为小于等于基准和大于基准的两部分。 递归：对两个子区间递归排序。 特点： 平均时间复杂度：O(n log n)。 最坏情况（如已排序或逆序数组）：O(n²)。 优化：三数取中或随机化基准减少最坏情况概率。 实现细节： 分区方案：常用 Lomuto 或 Hoare 分区算法。 基准选择：三数取中避免极端情况（如已排序输入）。 2. 堆排序 当快速排序的递归深度超过阈值（通常为 2 * log n），Introsort 切换到堆排序，以避免快速排序的最坏情况。 步骤： 构建最大堆（或最小堆，取决于排序顺序）。 反复将堆顶元素移到末尾并调整堆。 特点： 时间复杂度：始终为 O(n log n)。 空间复杂度：O(1)（原地排序）。 适合处理快速排序退化的场景。 实现细节： 使用数组表示堆，通过下标计算父子节点关系。 堆调整（sift-down）确保堆性质。 3. 插入排序 当子区间大小较小时（通常 &lt; 16 或 32 个元素，具体阈值依实现而定），Introsort 切换到插入排序。 步骤： 逐个将元素插入到已排序的子序列中。 特点： 时间复杂度：O(n²)，但在小数组上常数开销低。 适合部分有序或小规模数据。 实现细节： 通常通过循环实现，避免递归。 常用于优化小规模子区间的排序。 原因： 快速排序：平均性能优异，但在最坏情况下（如已排序或重复元素）退化为 O(n²)。 堆排序：保证最坏情况 O(n log n)，但平均性能稍逊，且堆调整开销较高。 插入排序：在小规模数据上高效，减少递归开销。 Introsort 动态切换算法，确保： 高效性：利用快速排序的平均性能。 鲁棒性：通过堆排序避免最坏情况。 优化性：插入排序处理小数组。 自定义排序 1. 函数指针 定义一个独立的比较函数，签名需为bool(T, T)： 123456bool compare(int a, int b) &#123; return a &gt; b; // 降序排序&#125;std::vector&lt;int&gt; vec = &#123;5, 2, 9, 1, 5&#125;;std::sort(vec.begin(), vec.end(), compare); // 结果为 &#123;9, 5, 5, 2, 1&#125; 2. 静态成员函数 在类中定义静态比较函数，避免依赖对象实例： 123456789class Sorter &#123;public: static bool compare(int a, int b) &#123; return a &gt; b; // 降序排序 &#125;&#125;;std::vector&lt;int&gt; vec = &#123;5, 2, 9, 1, 5&#125;;std::sort(vec.begin(), vec.end(), Sorter::compare); 注意：非静态成员函数因隐含this指针，签名不匹配std::sort的要求，因此无法直接使用。 3. 使用函数对象 通过定义一个类并重载operator()，可以在比较器中存储状态： 1234567891011class Comparator &#123; int threshold;public: Comparator(int t) : threshold(t) &#123;&#125; bool operator()(int a, int b) const &#123; return a &gt; threshold &amp;&amp; a &lt; b; // 仅对大于threshold的元素降序排序 &#125;&#125;;std::vector&lt;int&gt; vec = &#123;5, 2, 9, 1, 5&#125;;std::sort(vec.begin(), vec.end(), Comparator(3)); 4. 使用Lambda表达式（C++11及以上） Lambda表达式提供了一种简洁的方式定义比较器，并可捕获外部变量： 12345int threshold = 3;std::vector&lt;int&gt; vec = &#123;5, 2, 9, 1, 5&#125;;std::sort(vec.begin(), vec.end(), [threshold](int a, int b) &#123; return a &gt; threshold &amp;&amp; a &lt; b;&#125;); 5. 使用std::function C++11引入的std::function可以包装任何可调用对象（包括函数指针、Lambda、函数对象等），提供更灵活的方式： 1234567#include &lt;functional&gt;std::function&lt;bool(int, int)&gt; comp = [](int a, int b) &#123; return a &gt; b; // 降序排序&#125;;std::vector&lt;int&gt; vec = &#123;5, 2, 9, 1, 5&#125;;std::sort(vec.begin(), vec.end(), comp); 适用场景：当需要在运行时动态选择比较器时，std::function非常有用，但会引入少量性能开销。 6. 使用标准比较器（如std::greater、std::less） C++标准库提供了预定义的比较器（如&lt;functional&gt;中的std::greater和std::less），可直接用于简单排序需求： 1234#include &lt;functional&gt;std::vector&lt;int&gt; vec = &#123;5, 2, 9, 1, 5&#125;;std::sort(vec.begin(), vec.end(), std::greater&lt;int&gt;()); // 降序排序std::sort(vec.begin(), vec.end(), std::less&lt;int&gt;()); // 升序排序 优点：无需手动定义比较器，代码简洁，适合常见升序或降序需求。 7. 重载operator&lt; 对于自定义结构体或类，可以通过重载operator&lt;来定义默认排序规则，省去显式比较器： 12345678910struct Person &#123; std::string name; int age; bool operator&lt;(const Person&amp; other) const &#123; return age &lt; other.age; // 按年龄升序 &#125;&#125;;std::vector&lt;Person&gt; people = &#123;&#123;&quot;Alice&quot;, 25&#125;, &#123;&quot;Bob&quot;, 30&#125;, &#123;&quot;Charlie&quot;, 20&#125;&#125;;std::sort(people.begin(), people.end()); // 使用operator&lt;，按年龄升序 适用场景：当类型有自然的排序规则且不需要多种排序方式时，重载operator&lt;是最简洁的方案。 自定义结构体或类的排序 当排序对象是自定义结构体或类时，可以结合上述方法。例如，使用Lambda： 123456std::vector&lt;Person&gt; people = &#123;&#123;&quot;Alice&quot;, 25&#125;, &#123;&quot;Bob&quot;, 30&#125;, &#123;&quot;Charlie&quot;, 20&#125;&#125;;// 按名字字典序排序std::sort(people.begin(), people.end(), [](const Person&amp; a, const Person&amp; b) &#123; return a.name &lt; b.name;&#125;);","tags":["C++"],"categories":["学习记录","C++"]},{"title":"算法设计与复杂度分析2025试卷","path":"/posts/15575.html","content":"开卷考试 讲讲顺序算法中的分治法和回溯法的基本思想（20分） （1）一个 0-1背包问题(即限定每种物品只能选择0个或1个，不能拆分)中，若各个物品按照重量递增顺序排列时，其价值正好按照递减序排列。对这个特殊的 0-1背包问题，设计一个算法，找出该问题的解。 本题不限定方法。需要设计算法，需要给出复杂性分析。你可以选择完成可以展现你所设计算法优势的其它分析。（30分） （2）若上诉的01背包为超递增背包，即各个物品重量以超递增速度增加。设计多项式时间算法求解改背包问题，说明算法正确性，证明算法能求最优解（30分） 证明3-SAT 问题可以多项式归结到MSP问题（25分）","tags":["湘潭大学","考试资料"],"categories":["湘潭大学计算机研究生课程","算法设计与复杂度分析-姜新文"]},{"title":"linux常用命令","path":"/posts/30335.html","content":"Linux 命令总结 1. 文件操作 命令 示例 重要参数 解释（英文全称） 中文解释 参数作用 ls ls -l /dir -l, -a, -h, -t List 列出目录内容 -l: 长格式; -a: 显示隐藏文件; -h: 可读单位; -t: 按时间排序 cd cd /home/user – Change Directory 切换目录 无常用参数，直接跟路径即可 pwd /home/user – Print Working Directory 显示当前工作目录 无参数，直接输出当前路径 mkdir mkdir -p /dir/subdir -p Make Directory 创建目录 -p: 自动创建父目录（若不存在） rm rm -rf /dir -r, -f Remove 删除文件或目录 -r: 递归删除; -f: 强制删除，不提示 cp cp -r file1 /dir -r, -p Copy 复制文件或目录 -r: 递归复制目录; -p: 保留文件属性（如权限、时间戳） mv mv file1 file2 -i Move 移动或重命名文件 -i: 覆盖前提示 cat cat file.txt -n Concatenate 查看文件内容 -n: 显示行号 touch touch newfile.txt -t Touch 创建空文件或更新时间 -t: 指定时间戳（如 -t 202301011200） find find / -name “file.txt” -name, -type, -size Find 查找文件 -name: 按文件名; -type: 文件类型; -size: 按大小（如 +10M） ln ln -s file link -s Link 创建链接 -s: 创建符号链接（软链接） stat stat file.txt – Status 显示文件详细信息 无常用参数，显示文件元数据（如权限、大小、时间戳） file file file.txt – File 查看文件类型 无参数，判断文件类型（如文本、二进制） diff diff file1 file2 -u Difference 比较文件差异 -u: 以统一格式输出差异 2. 系统监控 命令 示例 重要参数 解释（英文全称） 中文解释 参数作用 top top -u Table of Processes 查看实时进程信息 -u: 指定用户进程（如 -u user） htop htop – Hisham’s Top 更友好的进程查看工具 无常用参数，图形化交互界面 ps ps aux aux -ef Process Status 查看进程状态 a: 所有终端进程; u: 用户信息; x: 无终端进程; -ef: 完整格式输出 df df -h -h, -i Disk Free 查看磁盘空间使用 -h: 可读单位; -i: 显示 inode 使用情况 du du -sh /dir -s, -h, -d Disk Usage 查看目录或文件大小 -s: 总大小; -h: 可读单位; -d: 指定深度（如 -d 1） free free -m -m, -t Free 查看内存使用情况 -m: MB 单位; -t: 显示总计行 uptime uptime – Uptime 查看系统运行时间 无参数，显示运行时间、用户数和负载 vmstat vmstat 1 5 -s Virtual Memory Stats 查看虚拟内存统计 -s: 显示内存统计表; 数字参数：采样间隔和次数 iostat iostat -x -x, -d Input/Output Stats 查看 I/O 统计 -x: 扩展统计; -d: 只显示设备统计 lscpu lscpu – List CPU 查看 CPU 信息 无参数，显示 CPU 架构、核心数等 uname uname -a -a Unix Name 查看系统信息 -a: 显示所有信息（如内核版本、主机名） 3. 权限管理 命令 示例 重要参数 解释（英文全称） 中文解释 参数作用 chmod chmod 755 file.sh -R Change Mode 修改文件权限 -R: 递归更改目录权限 chown chown user:group file -R Change Owner 修改文件所有者 -R: 递归更改目录所有者 sudo sudo apt update -u Superuser Do 以超级用户权限执行 -u: 以指定用户运行（如 -u user） whoami whoami – Who Am I 显示当前用户名 无参数，输出当前登录用户名 passwd passwd – Password 修改用户密码 无常用参数，交互式输入新密码 chgrp chgrp group file -R Change Group 修改文件所属组 -R: 递归更改目录所属组 umask umask 022 – User Mask 设置默认权限掩码 无参数，设置新建文件默认权限（如 022 表示新建文件权限为 644） 4. 网络相关 命令 示例 重要参数 解释（英文全称） 中文解释 参数作用 ping ping google.com -c, -i Packet Internet Groper 测试网络连通性 -c: 指定包数; -i: 指定发送间隔（如 -i 0.2） netstat netstat -tuln -t, -u, -l, -n Network Statistics 查看网络状态 -t: TCP; -u: UDP; -l: 监听端口; -n: 数字格式 curl curl -O url -O, -I Client URL 下载或请求网页数据 -O: 下载文件; -I: 只返回头部信息 wget wget -r url -r Web Get 下载文件 -r: 递归下载网站内容 ifconfig ifconfig eth0 up up, down Interface Config 配置网络接口 up: 启用接口; down: 禁用接口 ssh ssh user@host -p, -i Secure Shell 远程登录 -p: 指定端口; -i: 指定私钥文件（如 -i ~/.ssh/key） traceroute traceroute google.com -n Trace Route 跟踪路由路径 -n: 不解析主机名，仅显示 IP nc nc -zv host 80 -z, -v Netcat 网络调试工具 -z: 扫描端口; -v: 显示详细信息 ip ip addr show addr, link IP 查看或配置网络 addr: 显示地址; link: 显示接口状态 ss ss -tuln -t, -u, -l, -n Socket Statistics 查看套接字状态 -t: TCP; -u: UDP; -l: 监听; -n: 数字格式 5. 进程管理 命令 示例 重要参数 解释（英文全称） 中文解释 参数作用 kill kill -9 1234 -9, -15 Kill 终止进程 -9: SIGKILL 强制终止; -15: SIGTERM 优雅终止 pkill pkill -f process_name -f, -u Process Kill 按名称终止进程 -f: 按命令名匹配; -u: 按用户终止（如 -u user） nohup nohup script.sh &amp; – No Hang Up 后台运行不挂断 无参数，配合 &amp; 在终端关闭后继续运行 jobs jobs -l Jobs 查看后台任务 -l: 显示进程 ID bg bg %1 – Background 将任务放入后台 无参数，配合任务编号（如 %1） fg fg %1 – Foreground 将任务调回前台 无参数，配合任务编号（如 %1） nice nice -n 10 command -n Nice 设置进程优先级 -n: 指定优先级值（-20 到 19，值越低优先级越高） renice renice 10 -p 1234 -p Renice 修改运行进程优先级 -p: 指定进程 ID killall killall httpd -i Kill All 按名称杀死所有进程 -i: 交互式确认 6. 文件内容操作 命令 示例 重要参数 解释（英文全称） 中文解释 参数作用 grep grep -r “text” /dir -i, -r, -n Global Regular Expression Print 搜索文件内容 -i: 忽略大小写; -r: 递归搜索; -n: 显示行号 sed sed ‘s/old/new/g’ file -i Stream Editor 流编辑器 -i: 直接修改文件 awk awk ‘{print $1}’ file -F Aho, Weinberger, Kernighan 文本处理工具 -F: 指定分隔符（如 -F: 以冒号分隔） head head -n 5 file.txt -n Head 显示文件头部 -n: 指定行数（如 -n 5） tail tail -n 5 file.txt -n, -f Tail 显示文件尾部 -n: 指定行数; -f: 实时跟踪 less less file.txt -N Less 分页查看文件 -N: 显示行号 wc wc -l file.txt -l, -w, -c Word Count 统计行数、字数 -l: 行数; -w: 单词数; -c: 字符数 cut cut -d: -f1 file.txt -d, -f Cut 按字段截取文本 -d: 指定分隔符; -f: 指定字段（如 -f1 表示第一列） sort sort file.txt -r, -n Sort 排序文件内容 -r: 逆序; -n: 按数值排序 uniq uniq file.txt -c Unique 去除重复行 -c: 显示每行重复次数 7. 压缩与解压 命令 示例 重要参数 解释（英文全称） 中文解释 参数作用 tar tar -czvf file.tar.gz /dir -c, -z, -v, -f Tape Archive 打包与解包 -c: 创建; -z: gzip 压缩; -v: 显示过程; -f: 指定文件名 gzip gzip file.txt -d GNU Zip 压缩文件 -d: 解压（等同 gunzip） gunzip gunzip file.txt.gz – GNU Unzip 解压文件 无常用参数，解压 .gz 文件 zip zip -r file.zip /dir -r Zip 压缩为 zip 格式 -r: 递归压缩目录 unzip unzip file.zip -l Unzip 解压 zip 文件 -l: 仅列出文件内容，不解压 bzip2 bzip2 file.txt -d Burrows-Wheeler Zip 更高压缩比 -d: 解压（等同 bunzip2） 8. 软件管理 命令 示例 重要参数 解释（英文全称） 中文解释 参数作用 apt apt install package install, remove Advanced Package Tool Debian 系包管理 install: 安装; remove: 删除软件包 yum yum install package install, update Yellowdog Updater Modified CentOS 包管理 install: 安装; update: 更新软件包 dpkg dpkg -i package.deb -i, -r Debian Package 安装 deb 包 -i: 安装; -r: 删除 rpm rpm -ivh package.rpm -i, -v, -h Red Hat Package Manager 安装 rpm 包 -i: 安装; -v: 详细信息; -h: 进度条 snap snap install package –classic Snap 安装 snap 包 –classic: 允许访问系统资源 dnf dnf install package install, upgrade Dandified Yum Fedora 包管理 install: 安装; upgrade: 升级所有包 9. 日志查看 命令 示例 重要参数 解释（英文全称） 中文解释 参数作用 journalctl journalctl -u service -u, -f, -n Journal Control 查看系统日志 -u: 服务日志; -f: 实时跟踪; -n: 指定行数 dmesg dmesg grep error -T Diagnostic Message 查看内核日志 last last -x -x Last 查看登录历史 -x: 显示系统事件（如关机、重启） logrotate logrotate -f config -f Log Rotate 轮转日志文件 -f: 强制执行轮转 10. 环境变量管理 命令 示例 重要参数 解释（英文全称） 中文解释 参数作用 env env – Environment 查看环境变量 无参数，列出所有环境变量 export export VAR=value – Export 设置环境变量 无参数，设置并导出变量到子进程 unset unset VAR – Unset 删除环境变量 无参数，移除指定变量 set set – Set 查看所有变量 无参数，显示环境变量和 shell 函数 11. 用户管理 命令 示例 重要参数 解释（英文全称） 中文解释 参数作用 useradd useradd -m user -m, -s User Add 添加用户 -m: 创建家目录; -s: 指定 shell（如 -s /bin/bash） usermod usermod -aG group user -aG User Modify 修改用户信息 -aG: 添加用户到组（附加，不覆盖） userdel userdel -r user -r User Delete 删除用户 -r: 删除用户及其家目录 groupadd groupadd group – Group Add 添加用户组 无常用参数，直接创建组 id id user – Identity 查看用户身份 无参数，显示用户 UID、GID 和组信息 12. 磁盘管理 命令 示例 重要参数 解释（英文全称） 中文解释 参数作用 fdisk fdisk /dev/sda -l Fixed Disk 管理磁盘分区 -l: 列出分区表 mkfs mkfs.ext4 /dev/sda1 – Make Filesystem 格式化文件系统 无常用参数，指定文件系统类型（如 ext4） mount mount /dev/sda1 /mnt -t Mount 挂载文件系统 -t: 指定文件系统类型（如 -t ext4） umount umount /mnt – Unmount 卸载文件系统 无常用参数，直接卸载挂载点 lsblk lsblk -f List Block 列出块设备 -f: 显示文件系统类型和挂载点 13. 任务调度 命令 示例 重要参数 解释（英文全称） 中文解释 参数作用 cron crontab -e -e, -l Command Run On 定时任务 -e: 编辑任务; -l: 列出任务 at at now + 1 hour – At 单次定时任务 无参数，指定执行时间（如 now + 1 hour） batch batch – Batch 批量任务 无参数，在系统负载低时执行 14. 性能分析 命令 示例 重要参数 解释（英文全称） 中文解释 参数作用 strace strace -p 1234 -p, -o System Trace 跟踪系统调用 -p: 指定进程 ID; -o: 输出到文件 lsof lsof -p 1234 -p, -i List Open Files 列出打开文件 -p: 指定进程; -i: 显示网络文件 perf perf stat command stat, record Performance 性能分析 stat: 统计性能; record: 记录数据 sar sar -u 1 5 -u System Activity Report 系统活动报告 -u: CPU 使用情况; 数字参数：采样间隔和次数","categories":["学习记录","Linux"]},{"title":"Linux文件目录理解","path":"/posts/58113.html","content":"前言 最近在复习linux，发现有些目录总是忘记内容，发现有些还是得从原义和实际例子去理解会记忆深刻些。以下是个人的一些理解 Linux目录 常见的Linux下的目录如下： 1. 根目录 / (Root Directory) 英文含义：/ 是文件系统的根（root）目录。它是所有文件和目录的起点，类似于树的根，所有其他文件夹和文件都是从这里延伸出来的。 作用：作为文件系统的根目录，它是所有路径的起始点。 PS：根目录在系统启动初期可能是只读挂载的，普通用户无法直接在根目录下创建文件，只有管理员（root 用户）有权限操作。 实际例子：运行 ls / 可以列出根目录下的所有子目录 2. /bin (Binary Files) 英文含义：bin 是 “binary”（二进制）的缩写，表示存放可执行程序的地方。这些二进制文件是操作系统和用户交互的基本命令。 作用：包含启动和运行操作系统所需的基本命令。这里的命令是系统和用户都可以使用的，甚至在单用户模式下也可以执行。 常见文件： /bin/ls：列出当前目录下的文件和文件夹（ls 是 “list” 的缩写）。 /bin/cp：复制文件或目录（cp 是 “copy” 的缩写）。 /bin/mv：移动或重命名文件或目录（mv 是 “move” 的缩写）。 /bin/rm：删除文件或目录（rm 是 “remove” 的缩写）。 PS：在现代 Linux 发行版中，/bin 有时会符号链接到 /usr/bin，这是因为 Filesystem Hierarchy Standard (FHS) 的演进，旨在统一二进制文件存放位置。 实际例子：运行 which ls 会返回 /bin/ls，告诉你 ls 命令的具体路径。 3. /sbin (System Binary Files) 英文含义：sbin 是 “system binary”（系统二进制）的缩写，存放的是需要管理员权限来执行的系统管理命令。 作用：包含系统管理和维护所需的命令，普通用户一般不需要使用这些命令，除非是系统管理员。 常见文件： /sbin/init：系统初始化进程，是系统启动时运行的第一个程序。 /sbin/reboot：重启系统的命令。 /sbin/shutdown：关闭系统的命令。 PS：这些命令通常需要超级用户权限（sudo），普通用户尝试直接运行会提示权限不足。 实际例子：执行 sudo /sbin/fdisk -l 可以列出磁盘分区信息（需要 root 权限）。这些命令通常用于系统维护和调试。 4. /etc (Etcetera - Configuration Files) 英文含义：etc 是 “et cetera”（等等）的缩写，虽然这个名字没有直接说明它的内容，但通常用于存放系统配置文件（历史遗留问题，遗传unix）。 作用：包含所有系统和程序的配置文件。通常会在这里配置一些与程序、用户、服务等相关的设置。 常见文件： /etc/passwd：存储用户账户信息的文件。这里包括每个用户的用户名、密码、UID 和 GID 等信息。 /etc/fstab：用于系统启动时挂载文件系统的配置文件。 /etc/hostname：存储系统主机名的文件。 /etc/network/interfaces：配置网络接口的文件。 PS：/etc 不仅是系统配置的中心，许多服务的配置文件也集中在这里，例如 Apache、Nginx 或 SSH。 常见文件补充： /etc/resolv.conf：定义 DNS 服务器地址，用于网络域名解析。 /etc/crontab：系统级别的定时任务配置文件。 实际例子：编辑 /etc/hosts 可以添加本地主机名解析，例如 127.0.0.1 mylocalserver。你可以在这些配置文件中修改系统和服务的行为。 5. /home (Home Directories) 英文含义：home 目录存放的是每个用户的家目录。这里是每个用户存放个人文件的地方。 作用：存放用户个人文件，会在这里存放自己的代码、文档等文件。 常见文件： /home/username：每个用户的个人目录，username 是你的用户名。例如，如果你的用户名是 oy，你的家目录就是 /home/oy。 PS：用户的家目录通常包含隐藏文件（以 . 开头），如 .bashrc 或 .profile，用于配置用户的 shell 环境。 实际例子：在 /home/username 下运行 ls -a 可以看到 .bash_history，记录用户执行过的命令历史。 6. /var (Variable Files) 英文含义：var 是 “variable”（可变的）的缩写，表示存放那些内容经常变化的文件。通常包括日志、缓存、队列等。 作用：存放程序运行时产生的动态数据，比如日志文件、缓存文件等。 常见文件： /var/log：存放日志文件的目录。可以在这里查看系统和应用程序的日志信息，用来调试程序。 /var/tmp：存放临时文件的目录，这些文件在系统重启后可能还会存在。 /var/spool：存放程序任务队列文件，比如邮件队列、打印队列等。 PS：/var 的内容通常与系统运行时间相关，占用空间可能会随时间增长，因此需要定期清理（如日志文件）。 常见文件补充： /var/mail：存放用户邮件的目录（如果系统配置了邮件服务）。 实际例子：运行 tail -f /var/log/syslog 可以实时查看系统日志，用于调试。 7. /lib 和 /lib64 (Libraries) 英文含义：lib 是 “library”（库）的缩写，包含了程序运行所依赖的共享库文件。 作用：存放系统和应用程序使用的共享库文件。共享库文件包含了程序运行时需要的函数、代码等。 常见文件： /lib/libc.so：C 标准库的共享库文件，很多程序都依赖它。 /lib64/libc.so：64 位版本的 C 标准库共享库文件。 PS：/lib64 只存在于 64 位系统上，用于区分 32 位和 64 位库文件。32 位库可能存放在 /lib32。 实际例子：运行 ldd /bin/ls 可以查看 ls 命令依赖的共享库文件路径。 8. /tmp (Temporary Files) 英文含义：tmp 是 “temporary”（临时的）的缩写，表示存放临时文件的地方。 作用：用于存储系统或应用程序在运行过程中产生的临时文件。通常这些文件不会永久保留，系统重启后有时会被清除。 常见文件： /tmp：存放临时文件的目录，程序在运行时可能会创建文件存放在这里。比如安装程序临时解压的文件、应用程序的缓存文件等。 PS：/tmp 的内容通常由系统服务（如 tmpfiles.d）或重启时自动清理，清理规则可能在 /etc/tmpfiles.d/ 中定义。 实际例子：运行 echo &quot;test&quot; &gt; /tmp/testfile 创建临时文件，重启后检查是否被清除。在处理临时数据时，可能会使用这个目录来存放文件，确保数据不会占用永久存储空间。 9. /dev (Device Files) 英文含义：dev 是 “devices”（设备）的缩写，表示设备文件的目录。 作用：存放所有设备文件，这些设备文件让用户和应用程序可以与硬件设备进行交互。设备文件可以是硬盘、键盘、显示器、串口等设备的接口。 常见文件： /dev/sda：表示系统中的第一个硬盘。 /dev/tty：表示终端设备，用于用户与系统交互的控制台。 /dev/null：空设备，写入它的所有数据都会丢失。常用它来丢弃不需要的输出。 PS：Linux 遵循“一切皆文件”的哲学，设备文件分为字符设备（如 /dev/tty）和块设备（如 /dev/sda）。 常见文件补充： /dev/random 和 /dev/urandom：生成随机数的伪设备文件，常用于加密或测试。 实际例子：运行 cat /dev/urandom | head -c 10 可以生成 10 字节的随机数据。常常会通过设备文件来与硬件设备进行交互，例如读写硬盘，控制外部设备等。 10. /mnt (Mount Points) 英文含义：mnt 是 “mount”（挂载）的缩写，表示挂载点的目录。 作用：用于临时挂载文件系统的目录。当你挂载一个磁盘或其他文件系统时，它的内容会显示在 /mnt 下的子目录中。 常见文件： /mnt：这个目录通常为空，系统管理员可以在这里挂载外部存储设备或分区。比如，挂载一个 USB 驱动器时，可能会在 /mnt/usb 下显示该驱动器的文件系统。 PS：与 /mnt 类似，/media 也常用于挂载，但 /media 更倾向于用户手动挂载的设备（如 U 盘）。 实际例子：运行 sudo mount /dev/sdb1 /mnt 将第二个硬盘的第一个分区挂载到 /mnt。有时会使用这个目录来挂载外部存储或进行调试。 11. /opt (Optional Add-on Software Packages) 英文含义：opt 是 “optional”（可选的）的缩写，表示可选的附加软件包。 作用：存放可选的第三方软件包及其相关文件。与 /usr 目录类似，但 /opt 通常用于那些不属于系统基础安装的软件。 常见文件： /opt：存放附加软件的目录。比如你安装了一些额外的第三方应用程序，它们通常会存放在这里。 PS：/opt 中的软件通常自成体系，包含自己的子目录（如 /opt/appname/bin），便于独立管理。 实际例子：安装 Google Chrome 时，它可能被放置在 /opt/google/chrome。一般会在这里安装一些额外的应用程序或库，以便开发自己的应用。 12. /usr (User Programs) 英文含义：usr 是 “user”（用户的）或 “Unix System Resources”（Unix 系统资源）的缩写。 作用：存放系统和应用程序的可执行文件、库文件以及共享数据等。这个目录包含了大部分的用户程序和资源文件。 常见文件： /usr/bin：存放用户应用程序的命令。 /usr/lib：存放系统和程序使用的库文件。 /usr/share：存放共享数据文件，如文档、图标、语言文件等。 /usr/local：存放本地安装的应用程序，通常由管理员手动安装，不属于系统默认软件。 PS：/usr 是系统安装后的大本营，通常占用较多磁盘空间。/usr/local 是用户自定义安装的首选位置，避免与系统包管理器冲突。 常见文件补充： /usr/include：存放 C/C++ 的头文件，编译程序时需要。 实际例子：运行 /usr/bin/python3 启动系统安装的 Python 解释器。通常会在 /usr 下存放安装的软件包和共享资源。 13. /srv (Service Data) 英文含义：srv 是 “service”（服务）的缩写，表示服务数据的目录。 作用：存放服务提供的数据，通常是系统服务或者用户服务的文件。例如，网站的页面文件、数据库文件等。 常见文件： /srv/www：存放 Web 服务器的数据文件，如网站的文件。 /srv/ftp：存放 FTP 服务器的数据文件。 PS：/srv 的使用因系统而异，有些发行版可能不默认使用，管理员可以根据需要自定义。 实际例子：运行 Nginx 时，可以将网站文件放在 /srv/www/html。可能会在这里放置由服务器提供的数据或文件，如网站文件、数据库文件等。 14. /sys (System Information) 英文含义：sys 是 “system”（系统）的缩写，表示系统信息的目录。 作用：提供关于系统内核和硬件的实时信息。这里存放了很多虚拟文件，它们代表了系统的状态，可以通过读取这些文件来获取系统的运行状态。 常见文件： /sys/class：存放系统硬件的信息，如网络设备、存储设备等。 /sys/fs：存放文件系统的信息，如挂载的文件系统。 PS：/sys 是 sysfs 文件系统的一部分，与 /proc 类似，但更专注于硬件和内核参数。 15. /proc (Process Information) 英文含义：proc 是 “process”（进程）的缩写，表示进程信息的目录。 作用：提供关于运行中的进程、内核等信息。这个目录下的文件是虚拟文件，它们不存储数据，而是内核实时生成的数据。可以用它来监控系统状态，获取进程信息。 常见文件： /proc/cpuinfo：显示 CPU 信息。 /proc/meminfo：显示内存使用情况。 /proc/[pid]：每个进程都有一个对应的目录，[pid] 是进程 ID。你可以在这里查看进程的内存、CPU 使用情况等。 PS：/proc 是 procfs 文件系统，内容完全动态生成，占用内存而非磁盘空间。 常见文件补充： /proc/uptime：显示系统运行时间（秒）和空闲时间。 实际例子：运行 cat /proc/self/stat 查看当前进程（即 cat 命令本身）的状态。可以通过 /proc 目录获取系统资源的详细信息，用于性能监控或调试。 16. /boot (Boot Loader Files) 英文含义：boot 是 “bootstrap”（引导）的缩写，表示系统启动相关文件。 作用：存放启动加载程序（bootloader，如 GRUB）和内核映像文件。 常见文件： /boot/vmlinuz：压缩的 Linux 内核文件。 /boot/grub/grub.cfg：GRUB 引导配置文件。 17. /run (Runtime Data) 英文含义：run 表示运行时数据。 作用：存放系统运行时的临时文件（如 PID 文件或锁文件），通常在重启后清空。 常见文件： /run/lock：存放锁文件，防止多个进程冲突。 实际例子：运行 cat /run/mysqld/mysqld.pid 查看 MySQL 服务的进程 ID。 18. /lost+found 英文含义：表示“丢失并找到”的文件。 作用：在文件系统检查（如 fsck）后，损坏或未链接的文件会存放在这里。 建议 自己手动查看一下目录","categories":["学习记录","Linux"]},{"title":"单例模式","path":"/posts/46132.html","content":"单例模式（Singleton Pattern） 是一种常见的设计模式，它确保一个类只有一个实例，并提供全局访问点来获取该实例。换句话说，单例模式保证某个类在整个应用程序生命周期中只有一个实例，并提供一个全局的访问接口来获取该实例。 单例模式的关键特点： 唯一性：类只有一个实例。 全局访问：可以通过一个全局的静态方法访问到这个实例。 延迟初始化：单例实例的创建通常是懒加载的（即在第一次使用时才创建实例）。 单例模式的应用场景： 需要控制某个类的实例数量（例如，配置管理器、日志记录器、数据库连接池等）。 需要确保全局只有一个对象，并且该对象需要被多个地方共享。 单例模式的实现方式： 1. 懒汉式（Lazy Singleton）：延迟实例化 这种方式只有在第一次访问时才创建实例，延迟到真正需要时才创建。 1234567891011121314151617181920212223class Singleton &#123;private: static Singleton* instance; // 静态指针，指向唯一实例 // 构造函数私有，防止外部通过构造函数创建对象 Singleton() &#123;&#125;public: // 获取唯一实例的方法 static Singleton* getInstance() &#123; if (instance == nullptr) &#123; instance = new Singleton(); // 延迟实例化 &#125; return instance; &#125; // 禁止拷贝构造和赋值操作，确保只有一个实例 Singleton(const Singleton&amp;) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete;&#125;;// 初始化静态成员Singleton* Singleton::instance = nullptr; 优点：延迟实例化，只有在需要时才创建实例。 缺点：线程不安全，如果在多线程环境中并发访问 getInstance，可能会导致创建多个实例。 2. 饿汉式（Eager Singleton）：提前实例化 这种方式在程序启动时就创建实例，确保在整个生命周期中只有一个实例。 1234567891011121314151617181920class Singleton &#123;private: static Singleton* instance; // 静态指针，指向唯一实例 // 构造函数私有 Singleton() &#123;&#125;public: // 获取唯一实例的方法 static Singleton* getInstance() &#123; return instance; // 返回实例 &#125; // 禁止拷贝构造和赋值操作 Singleton(const Singleton&amp;) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete;&#125;;// 静态成员在程序启动时即初始化Singleton* Singleton::instance = new Singleton(); 优点：实例在程序启动时就创建，线程安全。 缺点：即使实例未被使用，也会在程序启动时创建。 3. 线程安全的懒汉式（Double-Checked Locking） 为了在多线程环境下保证单例的唯一性，使用锁机制来保证线程安全，同时避免每次访问时都进行锁操作。 12345678910111213141516171819202122232425class Singleton &#123;private: static Singleton* instance; static std::mutex mtx; // 互斥锁 Singleton() &#123;&#125;public: static Singleton* getInstance() &#123; if (instance == nullptr) &#123; std::lock_guard&lt;std::mutex&gt; lock(mtx); // 加锁 if (instance == nullptr) &#123; instance = new Singleton(); // 双重检查 &#125; &#125; return instance; &#125; Singleton(const Singleton&amp;) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete;&#125;;// 初始化静态成员Singleton* Singleton::instance = nullptr;std::mutex Singleton::mtx; 优点：在多线程环境下确保只创建一个实例，性能较好。 缺点：稍微复杂，涉及锁机制。 4. 静态局部变量（C++11及以上） 利用静态局部变量，C++11标准保证静态局部变量的初始化是线程安全的。 12345678910111213class Singleton &#123;private: Singleton() &#123;&#125;public: static Singleton&amp; getInstance() &#123; static Singleton instance; // 静态局部变量，程序第一次调用时才会初始化 return instance; &#125; Singleton(const Singleton&amp;) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete;&#125;; 优点：简单，线程安全，不需要显式的锁。 缺点：实例是静态的，无法被销毁（在应用程序退出时才会被销毁）。 使用单例模式的注意事项： 全局访问点：单例模式提供全局访问点，但如果滥用会让代码变得难以测试和维护，因为任何地方都可以改变单例的状态。 线程安全：如果在多线程环境中使用，必须确保实例的创建过程是线程安全的。 内存泄漏：如果单例模式使用动态分配内存（例如 new），需要确保在程序结束时正确释放资源，防止内存泄漏。 什么时候使用单例模式： 需要一个共享资源或者全局状态，且只需要一个实例（例如，日志管理、配置管理器）。 想避免多次创建相同的对象，并且需要全局访问该对象。","tags":["C++"],"categories":["设计模式"]},{"title":"Ubuntu 20.04 + mysql 8 默认密码问题","path":"/posts/44849.html","content":"问题描述： Ubuntu20.04安装完mysql8之后无法登录，不知道密码 1mysql -u root 原因： 系统默认自动配置好了用户和强密码 解决办法： 1sudo cat /etc/mysql/debian.cnf 查看该文件 利用上面的user 和 passwd 即可登录mysql 1mysql -u(user) -p(passwd) 随后修改密码 进入mysql后执行以下命令： 12345use mysql; update user set authentication_string=&#x27;&#x27; where user=&#x27;root&#x27;; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;xxx&#x27;; #修改密码为xxx 退出后即可正常登录 1mysql -u root -p","tags":["MySQL"],"categories":["bug记录"]},{"title":"redis常用命令","path":"/posts/34206.html","content":"个人理解 一个大号的Map 安装 github官网下载https://github.com/redis/redis/archive/refs/tags/7.4.2.tar.gz 解压后执行： 12makesudo make install 启动服务端: 1redis-server 默认端口是6379 启动客户端 1redis-cli 命令 1. 字符串（String） 字符串是最基础的数据类型，适合存单个值，比如计数、缓存数据。 SET - 设置键值 用法：SET key value 例子：SET user &quot;张三&quot; 场景：存用户名。 GET - 获取值 用法：GET key 例子：GET user 场景：读取用户名。 INCR - 自增 1 用法：INCR key 例子：INCR views 场景：统计页面访问量。 DEL - 删除键 用法：DEL key 例子：DEL user 场景：清理无用数据。 2. 列表（List） 列表是有序的队列，可以从两端操作，适合存顺序数据。 LPUSH - 从左侧插入 用法：LPUSH key value 例子：LPUSH tasks &quot;写代码&quot; 结果：tasks 列表变成 [&quot;写代码&quot;]。 场景：添加新任务。 RPUSH - 从右侧插入 用法：RPUSH key value 例子：RPUSH tasks &quot;开会&quot; 结果：tasks 变成 [&quot;写代码&quot;, &quot;开会&quot;]。 场景：追加消息。 LPOP - 从左侧弹出 用法：LPOP key 例子：LPOP tasks 返回：“写代码”，剩 [&quot;开会&quot;]。 场景：完成任务。 LRANGE - 获取范围元素 用法：LRANGE key start stop 例子：LRANGE tasks 0 -1 返回：[&quot;开会&quot;]（全部元素）。 场景：查看任务列表。 3. 集合（Set） 集合是无序、不重复的元素集合，适合去重或关系操作。 SADD - 添加元素 用法：SADD key member 例子：SADD friends &quot;小明&quot; &quot;小红&quot; 结果：friends 集合是 &#123;&quot;小明&quot;, &quot;小红&quot;&#125;。 场景：添加好友。 SMEMBERS - 获取所有元素 用法：SMEMBERS key 例子：SMEMBERS friends 返回：[&quot;小明&quot;, &quot;小红&quot;]。 场景：列出所有好友。 SREM - 删除元素 用法：SREM key member 例子：SREM friends &quot;小明&quot; 结果：剩 &#123;&quot;小红&quot;&#125;。 场景：删除好友。 SINTER - 求交集 用法：SINTER key1 key2 例子：SINTER friends colleagues 返回：[&quot;小红&quot;]（假设 colleagues 有“小红”“小刚”）。 场景：找共同好友。 4. 哈希（Hash） 哈希像一个小表格，适合存结构化数据，比如对象。 HSET - 设置字段值 用法：HSET key field value 例子：HSET user:001 name &quot;张三&quot; age &quot;25&quot; 结果：user:001 是 &#123;name: &quot;张三&quot;, age: &quot;25&quot;&#125;。 场景：存用户信息。 HGET - 获取字段值 用法：HGET key field 例子：HGET user:001 name 返回：“张三”。 场景：读取姓名。 HGETALL - 获取所有字段和值 用法：HGETALL key 例子：HGETALL user:001 返回：&#123;name: &quot;张三&quot;, age: &quot;25&quot;&#125;。 场景：显示用户详情。 HDEL - 删除字段 用法：HDEL key field 例子：HDEL user:001 age 结果：剩 &#123;name: &quot;张三&quot;&#125;。 场景：删除年龄信息。","tags":["Redis"],"categories":["学习记录","数据库"]},{"title":"protobuf安装","path":"/posts/32845.html","content":"安装 github官方链接 https://github.com/protocolbuffers/protobuf/ 以protobuf21为例 https://github.com/protocolbuffers/protobuf/releases/download/v21.11/protobuf-all-21.11.zip windows 解压好文件夹后,使用cmake,vs,qt creator等工具打开该项目,进行编译,编译需要注意下面三个地方,测试部分可以取消掉,节省时间 编译完成后,进入build文件夹中,通常有以下文件protoc.exe,libprotobuf.dll,libproto.dll,一个可执行文件和两个动态库,如果是debug模式下这两个动态库为libprotobufd.dll,libprotod.dll 选择一个合适的路径,创建如下三个文件夹,将protoc.exe放入bin目录,libprotobuf.dll,libproto.dll放入lib目录 将前面下载解压后的protobuf-all-21.11.zip中的protobuf-3.21.11\\src\\google目录，将google拖入上面的include中即可 添加两个系统环境变量，一个bin，一个lib，刷新变量后，使用 1protoc --version 出现版本号便可以了 linux 以同样的版本为例，用https://github.com/protocolbuffers/protobuf/releases/download/v21.11/protobuf-all-21.11.tar.gz 解压后进入目录，执行以下命令： 123./configuremakesudo make install 如果期间出现报错，如动态库无法找到，可以利用find命令查找该动态库，然后将该路径添加到/etc/ld.so.conf 最后执行： 1protoc --version 出现版本号便可以了","tags":["ProtoBuf"],"categories":["学习记录","数据序列化"]},{"title":"cmake简单理解","path":"/posts/55690.html","content":"简介 CMake 是一个开源的跨平台构建系统生成工具，旨在简化和自动化项目的构建过程。它主要用于管理和控制软件构建的过程，特别是在处理复杂的项目结构和多个平台时。CMake 并不直接进行编译或链接，而是生成本地构建系统所需的文件（如 Makefile、Visual Studio 项目文件、Xcode 工程文件等），然后由这些工具进行实际的构建。 特点 跨平台支持： CMake 支持多种操作系统和编译器，包括 Windows、Linux、macOS、Android、iOS 等。它可以生成适应不同平台的构建文件，如 Makefile、Visual Studio、Xcode 工程文件等。 生成构建系统文件： CMake 通过读取 CMakeLists.txt 配置文件，生成适合目标平台的构建系统文件。这些文件可以是： Makefile：用于 Linux 或类 Unix 系统上的构建。 Visual Studio 项目文件：用于 Windows 上的 Visual Studio 环境。 Xcode 工程文件：用于 macOS 上的 Xcode 工具链。 易于管理复杂项目： CMake 允许你将项目分解为多个子模块（subdirectories），每个子模块都可以有自己的 CMakeLists.txt 文件，从而使得管理大项目变得更加简单。例如，CMake 可以方便地处理项目中的静态库、动态库和可执行文件的构建。 支持外部依赖管理： CMake 通过 find_package() 来查找和配置项目所依赖的外部库和工具。例如，可以查找 Qt、OpenGL、Boost 等库，并自动配置其路径。 支持多种编译选项： CMake 允许设置编译器标志、优化级别、编译标准等，可以方便地支持 Debug 和 Release 模式的切换。 简化配置和构建： CMake 使得配置和构建流程简化为几条命令，避免了手动修改和维护平台特定的构建脚本。 基本概念 CMakeLists.txt： CMake 项目中的核心文件是 CMakeLists.txt。它用于定义构建系统的规则，包括项目的源文件、依赖库、编译选项、构建目标等。一个 CMake 项目通常会有多个 CMakeLists.txt 文件，每个子目录都有一个 CMakeLists.txt 文件。 项目结构： CMake 项目的结构通常包含： CMakeLists.txt：用于配置项目的根目录文件。 src/：源代码文件夹。 build/：用于存放构建过程中生成的文件。 include/：头文件目录。 lib/：库文件目录。 示例结构： 123456789project/├── CMakeLists.txt├── src/│ ├── main.cpp│ └── other.cpp├── include/│ └── header.h└── lib/ └── library.a CMake 语法： CMake 使用一组简单的命令和语法，常见的命令包括： cmake_minimum_required(VERSION 3.16)：设置 CMake 的最低版本要求。 project(MyProject)：定义项目的名称。 add_executable(MyExecutable main.cpp)：定义一个可执行文件。 target_link_libraries(MyExecutable MyLibrary)：链接库。 find_package(Qt5 REQUIRED)：查找外部库（如 Qt）。 include_directories(path)：指定头文件路径。 set(VAR value)：定义变量。 add_subdirectory(path)：处理子目录的 CMakeLists.txt 文件。 实际例子： 123456project/├── CMakeLists.txt # 根目录├── card/│ └── CMakeLists.txt # card 子模块└── player/ └── CMakeLists.txt # player 子模块 当前有一个包含多个模块（card、windows 等）和依赖项（如 Qt）的项目，以下是从头到尾的构建流程： CMake 配置阶段： CMake 会扫描根目录的 CMakeLists.txt 文件，处理项目设置。 CMake 会依次处理每个子模块的 CMakeLists.txt 文件。 例如，在 card 子目录下，CMake 会生成一个名为 card 的静态库，链接 Qt 核心库。 根目录会通过 target_link_libraries() 连接各个模块，例如将 card 和其他模块（如 windows）链接到主程序 client。 编译阶段： 运行 make 或 cmake --build . 命令，编译器会将源文件编译成目标文件。 每个 .cpp 文件都会生成一个 .o 或 .obj 文件。 链接阶段： 链接器将目标文件和静态库/动态库链接成最终的可执行文件。 如果 card 是静态库，链接器会将 card 库的代码和目标文件合并。 如果依赖了动态库（如 Qt），链接器会将动态库的路径信息嵌入可执行文件。 生成可执行文件： 最终的 client 可执行文件会被生成。 安装阶段： 可执行文件和库文件（如果有的话）会被安装到指定的目录，准备部署和使用。","tags":["C++"],"categories":["学习记录","CMake"]},{"title":"npm包无法识别命令","path":"/posts/37904.html","content":"问题描述： 今天hexo新文章时，无法找到hexo命令，明明昨天还好好的，突然npm下的包都无法识别命令了。node版本如下： 原因： 环境变量没配好，去查看npm的变量时，它的路径是C:\\Users*\\AppData\\Roaming pm，进入文件夹啥也没有 解决办法： 使用npm config get prefix 找到当前包目录，添加到系统变量中即可","tags":["npm"],"categories":["bug记录"]},{"title":"Qt报错：无法定位程序输入点于动态链接库","path":"/posts/984.html","content":"问题描述： qt程序在编译release版本后正常运行，进入release下面的文件夹执行.exe会报错：无法定位程序输入点于动态链接库 原因： 系统环境变量中，Anaconda的mingw变量在前面冲突了 解决办法： 找到该项目的编译器路径，在环境变量-&gt;系统变量中将该编译器路径放在其他mingw上方，通过上移操作即可","tags":["Qt"],"categories":["bug记录"]},{"title":"Qt信号传递自定义类","path":"/posts/44138.html","content":"问题描述： 最近在写qt时遇到一个问题 信号传递一个引用自定义参数时，槽函数无法响应，且报错： 12QObject::connect: Cannot queue arguments of type &#x27;Cards&#x27;(Make sure &#x27;Cards&#x27; is registered using qRegisterMetaType().) 其中cards为自定义类 原因： Qt 信号槽机制的底层实现： Qt 的信号和槽机制底层是基于事件队列和线程间通信的。当信号发射时，它可能会将参数复制到事件队列中，或者跨线程传递。在跨线程传递信号和槽时，Qt 会尝试将参数序列化，以确保它能够在不同线程间传递。 引用和跨线程 引用（reference） 在内存中直接指向某个对象。当传递一个引用时，实际上并没有复制对象本身，而只是传递了该对象的地址。Qt 无法自动跨线程处理这种类型的参数，尤其是在不同线程之间。 这种行为会导致 QObject::connect 无法处理引用类型参数，因为引用无法被安全地序列化或跨线程传递。这就是为什么看到错误提示： 1QObject::connect: Cannot queue arguments of type &#x27;Cards&#x27;。 信号参数的队列化 当信号在一个线程发射，并且槽函数在另一个线程中时，Qt 会尝试将信号的参数“队列化”到目标线程中。这意味着： 值传递：Qt 会复制传递给信号的参数，以便它可以安全地传递。 引用传递：由于引用不容易在不同线程之间传递，Qt 会报错，提示无法队列化引用类型。 解决办法： 在main函数中加入以下代码： 1qRegisterMetaType&lt;Cards&gt;(&quot;Cards&amp;&quot;);//自定义类型注册为 Qt 元对象类型","tags":["Qt"],"categories":["bug记录"]},{"title":"网络编程总结","path":"/posts/48031.html","content":"网络编程总结 前言 从一个例子出发： 假设客户端希望从服务器下载一个名为 file.txt 的文件，整个过程大致如下： 客户端发起 HTTP 请求： 客户端通过向服务器发送一个 HTTP 请求来获取文件。请求的格式如下：GET /file.txt HTTP/1.1 Host: www.oy.com 客户端将通过 URL 解析和 DNS 查询，获取到目标服务器的 IP 地址。 建立 TCP 连接（TCP 三次握手）： 在发送 HTTP 请求之前，客户端和服务器需要通过 TCP 协议建立一个可靠的连接。三次握手的过程如下： 客户端发送 SYN 请求，向服务器提出连接请求。 服务器回复 SYN-ACK，确认连接请求。 客户端再次发送 ACK，表示连接建立完成。 客户端发送 HTTP 请求： 建立 TCP 连接后，客户端通过该连接发送 HTTP 请求，请求服务器提供 file.txt 文件。 服务器处理请求并发送响应： 服务器接收到请求后，从磁盘读取文件内容（例如，file.txt），并通过 TCP 连接将文件内容作为 HTTP 响应回传给客户端。为了提高性能，服务器可能会使用零拷贝技术，以避免重复的内存拷贝操作。 客户端接收响应并关闭连接： 客户端通过 TCP 协议接收响应，并将文件保存到本地。当文件接收完毕后，客户端可以发送一个 FIN 请求，开始断开连接。服务器确认后，完成四次挥手，安全地断开连接。 在上面的第四步服务器处理请求并发送响应时，系统往往要进行IO处理，常见的IO模型如下： I/O模型 核心概念： 阻塞与非阻塞 个人理解：阻塞和非阻塞一般讨论的是面对请求时的一种状态 阻塞（Blocking）： 阻塞 I/O 模型是指在 I/O 操作执行期间，程序会被阻塞，直到该操作完成。在此期间，进程无法执行其他任务。 例如： 服务器通过read() 系统调用来读取硬盘中的数据，当我们请求的资源不可用时（资源被占用，没有数据到达等等），会使得进程休眠，从现象看就是卡在那里。 非阻塞（Non-blocking）： 非阻塞 I/O 模型是指在 I/O 操作过程中，程序不会被阻塞。如果没有数据可以读取或写入，调用会立即返回，而不是等待 I/O 操作完成。 使用非阻塞 I/O 时，程序可以进行轮询或采取其他方法来检查是否可以继续处理 I/O 操作。 例如： 服务器程序可以通过设置O_NONBLOCK 标志将文件描述符设置为非阻塞模式，在这种模式下，如果 read() 无法立即完成，它们会立即返回而不会阻塞进程。 同步与异步 对于同步和异步，往往需要讨论的是多任务的场景，还得先引入并发，并行的概念。 并发：多个任务在同一个时间段内同时执行，如果是单核心计算机，CPU 会不断地切换任务来完成并发操作。 并行：多任务在同一个时刻同时执行，计算机需要有多核心，每个核心独立执行一个任务，多个任务同时执行，不需要切换。 同步：多任务开始执行，任务 A、B、C 全部执行完成后才算是结束。 异步：多任务开始执行，只需要主任务 A 执行完成就算结束，主任务执行的时候，可以同时执行异步任务 B、C，主任务 A 可以不需要等待异步任务 B、C 的结果。 一般系统中的同步，可以通过串行来实现，也就是一个任务一个任务处理，而异步可以通过并发或者并行。 五种模型 在网络IO的处理中，服务器还需要经过以下过程： 1. 阻塞IO模式 从上面的解释就可以知道，当服务器进程read读取消息内容时，如果该进程请求的资源不可用时（资源被占用，没有数据到达等等），会使得进程休眠，从现象看就是卡在那里。 2. 非阻塞IO模式 如果服务器进程将read设置为非阻塞，在读取消息数据时，会立刻返回读取的结果，不会等待。 3. 多路复用IO模式 讨论并发的情况：若我们服务器进程想要处理多个客户端发送请求，此时需要靠多线程来帮助实现，同时，我们的线程无法知道什么时候会有数据到达，因此我们多个的线程只能不断的去进询问，查看缓冲区是否有数据可读。这带来了两个问题： 如果请求数量过多，消耗的线程数量巨大 多个线程需要一直查询，无数据可读时，其余时间白白浪费了资源 因此，我们希望有个方法，只需要少量的资源，例如一个进程或者一个线程就能监控这庞大的请求。linux中提供了三个系统函数：select、poll、epoll。后续在详细讨论三个函数内容。简单来说，有了这些方法，我们的服务器进程可以调用一个它们就能监控多个客户端的请求，只要有资源可读时，函数就能返回可读的状态，这样避免了资源的浪费。 4. 信号驱动IO 在上面的多路复用IO模型中，都需要通过轮询的方法去进行检查可读状态，例如select,poll轮询所有文件描述符，而epoll是事件驱动，只监测变化的事件。它们的本质还是得需要一个线程去持续的监督。 而信号驱动 I/O 是通过 信号 通知进程或线程某个 I/O 操作已经完成。当 I/O 完成时，操作系统会向应用程序发送一个信号（如 SIGIO），通知它进行相应的处理。 信号驱动 I/O 通过异步的方式来通知进程，进程在收到信号时才会进行 I/O 操作。 5. 异步IO 以上讨论的四种办法中，都是进程在得知可读状态之后再去读取数据，那么为什么不能直接让系统去处理这个接受和读取数据的过程呢。 在前言部分已经解释了这个异步的概念。我们的进程不再负责数据的询问和读取，将这部分内容交给了内核去处理，主进程通知内核去读取数据，然后就去执行其他任务，当内核读取数据结束之后，通知主进程，主进程再处理这些数据，或者让线程处理。 一些关键区别： 信号驱动IO和异步IO的区别：数据读取方是谁。 在得知数据可读的这个过程，两者其实都是异步的，即都不需要主进程参与，但在得知数据可读之后，信号驱动IO还是需要主进程去读取这个数据，而异步IO模型是由系统读取完了直接通知主进程。 ​ 关键系统函数 零拷贝 当我们服务器程序需要发送数据时，其过程如下： 一个文件的发送需要以下过程： 调用读取函数，切换内核态，将数据从磁盘拷贝至缓冲区 切换到用户态，将数据从缓冲区读取至进程缓冲区中。 将数据从进程缓冲区拷贝至socket缓冲区。 最后再拷贝至网卡中，再由网卡进行数据发送 可以看出浪费了许多时间。 在linux中提供了两个方法： mmap 应用进程调用了mmap()后，系统会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系 统内核「共享」这个缓冲区; 应用进程再调用write()，操作系统直接将内核缓冲区的数据拷贝到socket缓冲区中，这一切都发生在内核态，由 CPU来搬运数据； 最后，系统把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里。 sendfile 函数形式如下： 12#include &lt;sys/socket.h&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count); 它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。 应用进程调用了sendfile()之后,系统会把磁盘的数据拷贝到内核的缓冲区里。然后操作系统直接将内核缓冲区的数据拷贝到socket缓冲区中，这一切都发生在内核态，由CPU来搬运数据，不在需要write函数 最后，系统把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里。 复用IO函数 1. select 概述： select 是最早的 I/O 多路复用机制之一，最早在 BSD Unix 中引入，并广泛应用于各类操作系统（包括 Linux）。它允许程序在多个文件描述符上等待 I/O 事件的发生，并在事件发生时通知程序。 工作原理： 程序调用 select 函数并传递三个集合（readfds、writefds、exceptfds），分别表示要监控的可读、可写和异常状态的文件描述符。 select 阻塞直到至少一个文件描述符的状态发生变化（如可读、可写或异常）。 当 select 返回时，它会告诉程序哪些文件描述符可以进行相应的操作。 优缺点： 优点： 简单易用，广泛支持，几乎在所有操作系统上都可用。 缺点： 性能问题：当监控的文件描述符数目很大时，select 会非常低效。每次调用时，程序需要将所有文件描述符从用户空间复制到内核空间，并且内核需要遍历所有的文件描述符进行检查。这样，文件描述符数目越多，性能就越差。 文件描述符数量限制：select 的文件描述符数量有上限（通常是 FD_SETSIZE，在 Linux 上通常是 1024）。这意味着，如果要监控更多的连接，需要对代码进行修改或使用其他方式。 示例： 123456789101112fd_set readfds;FD_ZERO(&amp;readfds);FD_SET(socket_fd, &amp;readfds);struct timeval timeout;timeout.tv_sec = 5;timeout.tv_usec = 0;int ret = select(socket_fd + 1, &amp;readfds, NULL, NULL, &amp;timeout);if (ret &gt; 0) &#123; // 处理 I/O&#125; 2. poll 概述： poll 是对 select 的改进，它解决了 select 文件描述符数量有限的缺点，但依然存在一些性能问题。poll 在功能上类似于 select，但它使用一个结构数组来表示要监控的文件描述符。 工作原理： 程序调用 poll 并传入一个 pollfd 结构数组，每个结构体包含文件描述符及其事件类型（POLLIN、POLLOUT、POLLERR 等）。 poll 阻塞直到一个或多个文件描述符的状态发生变化。 poll 不会像 select 那样限制文件描述符数量（受限于系统配置），因此适用于更大的连接数。 优缺点： 优点： 没有文件描述符数量限制，可以监控更多的文件描述符。 适用于中等规模的连接池。 缺点： 性能问题：虽然没有文件描述符数量限制，但 poll 仍然需要在每次调用时遍历所有的文件描述符，因此它的性能在连接数非常大的时候仍然比较低效。 内存消耗较高，因为需要为每个文件描述符分配一个 pollfd 结构。 示例： 12345678struct pollfd fds[1];fds[0].fd = socket_fd;fds[0].events = POLLIN;int ret = poll(fds, 1, 5000); // 阻塞 5 秒if (ret &gt; 0) &#123; // 处理 I/O&#125; 3. epoll 概述： epoll 是 Linux 特有的 I/O 多路复用机制，它是 select 和 poll 的进一步优化，设计用于解决这两者的性能瓶颈。epoll 采用事件驱动方式，它不需要每次调用时遍历所有文件描述符，而是通过内核事件通知机制来高效处理大量并发连接。 工作原理： 程序首先使用 epoll_create 创建一个 epoll 实例，该实例与一组文件描述符关联。 程序通过 epoll_ctl 注册感兴趣的文件描述符及其事件（如可读、可写、异常等）。 程序通过 epoll_wait 等待文件描述符的事件发生，一旦某个文件描述符有 I/O 操作准备好，epoll_wait 就会返回相应的事件。 优势：epoll 在事件触发时将只返回有事件的文件描述符，而不是遍历所有文件描述符，极大地提升了性能。 优缺点： 优点： 性能优越：epoll 通过事件通知机制避免了每次调用时遍历所有文件描述符的开销，性能上比 select 和 poll 优越，尤其在大量并发连接时。 无需重新扫描：epoll 支持边沿触发（edge-triggered）和水平触发（level-triggered），且每次只会返回有事件的文件描述符。 无文件描述符数量限制：epoll 不受文件描述符数量的限制，可以处理大规模的并发连接。 缺点： 只在 Linux 上可用，不适用于其他操作系统。 程序的设计可能稍微复杂，因为要处理事件的注册、等待和删除等操作。 示例： 123456789101112131415int epfd = epoll_create(1); // 创建 epoll 实例struct epoll_event event;event.events = EPOLLIN;event.data.fd = socket_fd;epoll_ctl(epfd, EPOLL_CTL_ADD, socket_fd, &amp;event); // 注册文件描述符struct epoll_event events[10];int ret = epoll_wait(epfd, events, 10, -1); // 阻塞直到事件发生if (ret &gt; 0) &#123; for (int i = 0; i &lt; ret; ++i) &#123; if (events[i].events &amp; EPOLLIN) &#123; // 处理 I/O &#125; &#125;&#125; 区别 特性 select poll epoll 核心数据结构 fd_set（位掩码） pollfd 结构体数组 epoll_event 结构体数组 文件描述符管理 位掩码，固定大小（1024） 动态数组，无固定大小限制 红黑树 + 双向链表，高效管理 事件存储 每次调用需要重新设置 每次调用需要重新设置 内核维护，事件驱动 内存开销 固定大小，较大 动态分配，较大 动态分配，较小 效率 低（遍历所有 fd） 低（遍历所有 fd） 高（只处理活跃 fd） 时间复杂度 O(n)（遍历所有 fd） O(n)（遍历所有 fd） O(log n)（添加/删除）O(k)（事件等待，k 为活跃 fd） 文件描述符数量限制 有限制（通常为 1024） 无硬性限制 无硬性限制 触发模式 水平触发（LT） 水平触发（LT） 支持水平触发（LT）和边缘触发（ET） 跨平台支持 广泛支持 广泛支持 仅限 Linux 实现复杂度 简单 简单 复杂 总结： select： 优点：实现简单，适合文件描述符数量较少的应用场景。 缺点：文件描述符数量有限，性能随着文件描述符的增多急剧下降。每次调用时都需要遍历所有文件描述符，且需要在内核空间和用户空间之间复制文件描述符集合，消耗较大。 poll： 优点：没有文件描述符数量的限制，相比 select，更加灵活，能够支持更多文件描述符。 缺点：虽然没有 select 的限制，但仍然需要遍历所有文件描述符，性能问题依旧存在，尤其在大量并发连接时。 epoll： 优点：性能极高，特别是在处理大量并发连接时。使用事件驱动机制，仅通知发生事件的文件描述符，避免了轮询和频繁的内存复制。适合高并发、大规模连接的应用。 缺点：实现较为复杂，且只在 Linux 上可用。程序设计相对复杂，需要处理事件注册、删除和触发等操作。 一个http服务器的简易实现 采用半同步半反应堆形式实现。 缺点： 主线程和工作线程共享请求队列，主线程往请求队列中添加任务，工作线程从请求队列中取出任务是互斥的操作，需要对请求队列进行加锁保护，导致白白浪费CPU时间； 每个工作线程在同一时间内只能处理一个客户请求，如果客户较多而工作线程较少，就会导致任务队列中堆积大量的任务对象，此时客户端的响应将越来越慢。而如果通过增加工作线程来解决这个问题，就会因为大量的上下文切换导致消耗大量的CPU时间 主函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;assert.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;string.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdlib.h&gt;#include&lt;cassert&gt;#include&lt;sys/epoll.h&gt;#include &quot;14_2_locker.h&quot;#include &quot;15_3_threadpool.h&quot;#include &quot;15_4_http_conn.h&quot;#define MAX_FD 65536#define MAX_EVENT_NUMBER 10000extern int addfd(int epollfd,int fd,bool one_shot);extern int removefd(int epollfd,int fd); void addsig(int sig,void(handler)(int),bool restart = true)&#123; struct sigaction sa; memset(&amp;sa,&#x27;\\0&#x27;,sizeof(sa)); sa.sa_handler = handler; if(restart)&#123; sa.sa_flags |= SA_RESTART; &#125; sigfillset(&amp;sa.sa_mask); assert(sigaction(sig,&amp;sa,NULL) != -1);&#125;void show_error(int connfd,const char *info)&#123; printf(&quot;%s&quot;,info); send(connfd,info,strlen(info),0); close(connfd);&#125;int main(int argc,char *argv[])&#123; if(argc &lt;= 2)&#123; printf(&quot;usage: %s ip_address port_number &quot;,basename(argv[0])); return 1; &#125; const char *ip = argv[1]; int port = atoi(argv[2]); addsig(SIGPIPE,SIG_IGN);//忽略SIGPIPE信号 threadpool&lt;http_conn&gt; *pool = NULL; try&#123; pool = new threadpool&lt;http_conn&gt;; &#125; catch(...)&#123;//捕获所有异常 return 1; &#125; http_conn *users = new http_conn[MAX_FD]; assert(users); int listenfd = socket(PF_INET,SOCK_STREAM,0); assert(listenfd &gt;= 0); struct linger tmp = &#123;1,0&#125;;//避免time_wait状态 //设置端口复用 // SO_LINGER 选项的设置有助于在快速关闭连接时让套接字能够尽快地释放资源，使得端口可以更快速地复用。 setsockopt(listenfd,SOL_SOCKET,SO_LINGER,&amp;tmp,sizeof(tmp)); int ret = 0; struct sockaddr_in address; bzero(&amp;address,sizeof(address)); address.sin_family = AF_INET; inet_pton(AF_INET,ip,&amp;address.sin_addr); address.sin_port = htons(port); ret = bind(listenfd,(struct sockaddr *)&amp;address,sizeof(address)); assert(ret &gt;= 0); ret = listen(listenfd,5); assert(ret &gt;= 0); epoll_event events[MAX_EVENT_NUMBER]; int epollfd = epoll_create(5); assert(epollfd != -1); addfd(epollfd,listenfd,false); http_conn::m_epollfd = epollfd; while (true)&#123; int number = epoll_wait(epollfd,events,MAX_EVENT_NUMBER,-1); if((number &lt; 0) &amp;&amp; (errno != EINTR))&#123; printf(&quot;epoll failure &quot;); break; &#125; for(int i=0; i&lt;number;++i)&#123; int sockfd = events[i].data.fd; //处理新到的客户连接 if(sockfd == listenfd)&#123; struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); int connfd = accept(listenfd,(struct sockaddr *)&amp;client_address,&amp;client_addrlength); if(connfd &lt; 0)&#123; printf(&quot;errno is: %d &quot;,errno); continue; &#125; if(http_conn::m_user_count &gt;= MAX_FD)&#123; show_error(connfd,&quot;Internal server busy&quot;); continue; &#125; users[connfd].init(connfd,client_address); &#125; else if(events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))&#123; users[sockfd].close_conn(); &#125; else if(events[i].events &amp; EPOLLIN)&#123; //根据读的结果，决定是将任务添加到线程池，还是关闭连接 if(users[sockfd].read())&#123; pool-&gt;append(users + sockfd); &#125; else&#123; users[sockfd].close_conn(); &#125; &#125; else if(events[i].events &amp; EPOLLOUT)&#123; if(!users[sockfd].write())&#123; users[sockfd].close_conn(); &#125; &#125; else&#123;&#125; &#125; &#125; close(epollfd); close(listenfd); delete [] users; delete pool; return 0;&#125; http消息的读取与分析 http_conn.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#ifndef HTTPCONNECTION_H#define HTTPCONNECTION_H#include&lt;unistd.h&gt; // read write close#include&lt;signal.h&gt; // 信号处理#include&lt;sys/types.h&gt; // socket bind listen accept#include&lt;sys/epoll.h&gt;#include&lt;fcntl.h&gt; #include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;// sockaddr_in#include&lt;arpa/inet.h&gt; /// inet_pton#include&lt;assert.h&gt;#include&lt;sys/stat.h&gt; // stat#include&lt;string.h&gt;#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys/mman.h&gt;// mmap#include&lt;stdarg.h&gt;// va_list va_start va_end#include&lt;errno.h&gt;#include &quot;14_2_locker.h&quot;class http_conn&#123;public: static const int FILENAME_LEN = 200; // 文件名的最大长度 static const int READ_BUFFER_SIZE = 2048; // 读缓冲区的大小 static const int WRITE_BUFFER_SIZE = 1024; // 写缓冲区的大小 enum METHOD&#123;GET = 0,POST,HEAD,PUT,DELETE,TRACE,OPTIONS,CONNECT,PATCH&#125;; // HTTP请求方法 enum CHECK_STATE&#123;CHECK_STATE_REQUESTLINE = 0,CHECK_STATE_HEADER,CHECK_STATE_CONTENT&#125;; // 解析客户请求时的主状态机状态 enum HTTP_CODE&#123;NO_REQUEST,GET_REQUEST,BAD_REQUEST,NO_RESOURCE,FORBIDDEN_REQUEST,FILE_REQUEST,INTERNAL_ERROR,CLOSED_CONNECTION&#125;; // 服务器处理HTTP请求的可能结果 enum LINE_STATUS&#123;LINE_OK = 0,LINE_BAD,LINE_OPEN&#125;; // 行的读取状态public: http_conn()&#123;&#125; ~http_conn()&#123;&#125;public: void init(int sockfd,const sockaddr_in &amp;addr);// 初始化新接受的连接 void close_conn(bool real_close = true);// 关闭连接 void process();// 处理客户请求 bool read();// 非阻塞读操作 bool write();// 非阻塞写操作 private: void init(); HTTP_CODE process_read();// 解析HTTP请求 bool process_write(HTTP_CODE ret);// 填充HTTP应答 // 下面这一组函数被process_read调用以分析HTTP请求 HTTP_CODE parse_request_line(char *text);// 解析请求行 HTTP_CODE parse_headers(char *text);// 解析请求头 HTTP_CODE parse_content(char *text);// 解析消息体 HTTP_CODE do_request();// 处理请求 char *get_line()&#123; return m_read_buf + m_start_line; &#125;// 获取一行 LINE_STATUS parse_line();// 分析一行 // 下面这一组函数被process_write调用以填充HTTP应答 void unmap();// 释放资源 bool add_response(const char *format,...);// 向m_write_buf中写入响应 bool add_content(const char *content);// 向m_write_buf中写入内容 bool add_status_line(int status,const char *title);// 向m_write_buf中写入状态行 bool add_headers(int content_length);// 向m_write_buf中写入响应头 bool add_content_length(int content_length);// 向m_write_buf中写入Content-Length bool add_linger();// 向m_write_buf中写入Connection bool add_blank_line();// 向m_write_buf中写入空行public: // 所有socket上的事件都被注册到同一个epoll内核事件表中，所以epoll文件描述符设置为静态的 static int m_epollfd; static int m_user_count;// 统计用户数量private: int m_sockfd;// 该HTTP连接的socket和对方的socket地址 sockaddr_in m_address;// 对方的socket地址 char m_read_buf[READ_BUFFER_SIZE];// 读缓冲区 int m_read_idx;// 标识读缓冲区中已经读入的客户数据的最后一个字节的下一个位置 int m_checked_idx;// 当前正在分析的字符在读缓冲区中的位置 int m_start_line;// 当前正在解析的行的起始位置 char m_write_buf[WRITE_BUFFER_SIZE];// 写缓冲区 int m_write_idx;// 写缓冲区中待发送的字节数 CHECK_STATE m_check_state;// 主状态机当前所处的状态 METHOD m_method;// 请求方法 char m_real_file[FILENAME_LEN];// 客户请求的目标文件的完整路径，其内容等于doc_root+m_url,doc_root是网站根目录 char *m_url;// 客户请求的目标文件的文件名 char *m_version;// HTTP协议版本号，我们仅支持HTTP/1.1 char *m_host;// 主机名 int m_content_length;// HTTP请求的消息体的长度 bool m_linger;// HTTP请求是否要求保持连接 char *m_file_address;// 客户请求的目标文件被mmap到内存中的起始位置 struct stat m_file_stat;// 目标文件的状态。通过它我们可以判断文件是否存在、是否为目录、是否可读，并获取文件大小等信息 struct iovec m_iv[2];// 采用writev来执行写操作，定义两个成员，其中一个指向m_write_buf,另一个指向m_file_address int m_iv_count;// 表示被写内存块的数量&#125;;#endif http_conn.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451#include &quot;15_4_http_conn.h&quot;const char *ok_200_title = &quot;OK&quot;;const char *error_400_title = &quot;Bad Request&quot;;const char *error_400_form = &quot;Your request has bad syntax or is inherently impossible to satisfy. &quot;;const char *error_403_title = &quot;Forbidden&quot;;const char *error_403_form = &quot;You do not have permission to get file from this server. &quot;;const char *error_404_title = &quot;Not Found&quot;;const char *error_404_form = &quot;The requested file was not found on this server. &quot;;const char *error_500_title = &quot;Internal Error&quot;;const char *error_500_form = &quot;There was an unusual problem serving the requested file. &quot;;const char *doc_root = &quot;/var/www/html&quot;;int setnonblocking(int fd)&#123; int old_option = fcntl(fd,F_GETFL); int new_option = old_option | O_NONBLOCK; fcntl(fd,F_SETFL,new_option); return old_option;&#125;void addfd(int epollfd,int fd,bool one_shot)&#123; epoll_event event; event.data.fd = fd; event.events = EPOLLIN | EPOLLET | EPOLLRDHUP; if(one_shot)&#123; event.events |= EPOLLONESHOT; &#125; epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;event); setnonblocking(fd);&#125;void removefd(int epollfd,int fd)&#123; epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,0); close(fd);&#125;void modfd(int epollfd,int fd,int ev)&#123; epoll_event event; event.data.fd = fd; event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP; epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;event);&#125;int http_conn::m_epollfd = -1;int http_conn::m_user_count = 0;void http_conn::close_conn(bool real_close)&#123; if(real_close &amp;&amp; (m_sockfd != -1))&#123; removefd(m_epollfd,m_sockfd); m_sockfd = -1; m_user_count--; &#125;&#125;void http_conn::init(int sockfd,const sockaddr_in &amp;addr)&#123; m_sockfd = sockfd; m_address = addr; addfd(m_epollfd,sockfd,true); m_user_count++; init();&#125;void http_conn::init()&#123; m_check_state = CHECK_STATE_REQUESTLINE; m_linger = false; m_method = GET; m_url = 0; m_version = 0; m_content_length = 0; m_host = 0; m_start_line = 0; m_checked_idx = 0; m_read_idx = 0; m_write_idx = 0; memset(m_read_buf,&#x27;\\0&#x27;,READ_BUFFER_SIZE); memset(m_write_buf,&#x27;\\0&#x27;,WRITE_BUFFER_SIZE); memset(m_real_file,&#x27;\\0&#x27;,FILENAME_LEN);&#125;// 从状态机，用于解析出一行内容http_conn::LINE_STATUS http_conn::parse_line()&#123; char temp; for(;m_checked_idx &lt; m_read_idx;++m_checked_idx)&#123; temp = m_read_buf[m_checked_idx]; if(temp == &#x27;\\r&#x27;)&#123; if((m_checked_idx + 1) == m_read_idx)&#123; return LINE_OPEN; &#125; else if(m_read_buf[m_checked_idx + 1] == &#x27; &#x27;)&#123; m_read_buf[m_checked_idx++] = &#x27;\\0&#x27;; m_read_buf[m_checked_idx++] = &#x27;\\0&#x27;; return LINE_OK; &#125; return LINE_BAD; &#125; else if(temp == &#x27; &#x27;)&#123; if((m_checked_idx &gt; 1) &amp;&amp; (m_read_buf[m_checked_idx - 1] == &#x27;\\r&#x27;))&#123; m_read_buf[m_checked_idx - 1] = &#x27;\\0&#x27;; m_read_buf[m_checked_idx++] = &#x27;\\0&#x27;; return LINE_OK; &#125; return LINE_BAD; &#125; &#125; return LINE_OPEN;&#125;// 循环读取客户数据，直到无数据可读或对方关闭连接bool http_conn::read()&#123; if(m_read_idx &gt;= READ_BUFFER_SIZE)&#123; return false; &#125; int bytes_read = 0; while(true)&#123; bytes_read = recv(m_sockfd,m_read_buf + m_read_idx,READ_BUFFER_SIZE - m_read_idx,0); if(bytes_read == -1)&#123; if(errno == EAGAIN || errno == EWOULDBLOCK)&#123; break; &#125; return false; &#125; else if(bytes_read == 0)&#123; return false; &#125; m_read_idx += bytes_read; &#125; return true;&#125;// 解析HTTP请求http_conn::HTTP_CODE http_conn::process_read()&#123; LINE_STATUS line_status = LINE_OK; HTTP_CODE ret = NO_REQUEST; char *text = 0; while(((m_check_state == CHECK_STATE_CONTENT) &amp;&amp; (line_status == LINE_OK)) || ((line_status = parse_line()) == LINE_OK))&#123; text = get_line(); m_start_line = m_checked_idx; printf(&quot;got 1 http line: %s &quot;,text); switch(m_check_state)&#123; case CHECK_STATE_REQUESTLINE:&#123; ret = parse_request_line(text); if(ret == BAD_REQUEST)&#123; return BAD_REQUEST; &#125; break; &#125; case CHECK_STATE_HEADER:&#123; ret = parse_headers(text); if(ret == BAD_REQUEST)&#123; return BAD_REQUEST; &#125; else if(ret == GET_REQUEST)&#123; return do_request(); &#125; break; &#125; case CHECK_STATE_CONTENT:&#123; ret = parse_content(text); if(ret == GET_REQUEST)&#123; return do_request(); &#125; line_status = LINE_OPEN; break; &#125; default:&#123; return INTERNAL_ERROR; &#125; &#125; &#125; return NO_REQUEST;&#125;// 解析请求行http_conn::HTTP_CODE http_conn::parse_request_line(char *text)&#123; m_url = strpbrk(text,&quot; \\t&quot;); if(!m_url)&#123; return BAD_REQUEST; &#125; *m_url++ = &#x27;\\0&#x27;; char *method = text; if(strcasecmp(method,&quot;GET&quot;) == 0)&#123; m_method = GET; &#125; else&#123; return BAD_REQUEST; &#125; m_url += strspn(m_url,&quot; \\t&quot;); m_version = strpbrk(m_url,&quot; \\t&quot;); if(!m_version)&#123; return BAD_REQUEST; &#125; *m_version++ = &#x27;\\0&#x27;; m_version += strspn(m_version,&quot; \\t&quot;); if(strcasecmp(m_version,&quot;HTTP/1.1&quot;) != 0)&#123; return BAD_REQUEST; &#125; if(strncasecmp(m_url,&quot;http://&quot;,7) == 0)&#123; m_url += 7; m_url = strchr(m_url,&#x27;/&#x27;); &#125; if(!m_url || m_url[0] != &#x27;/&#x27;)&#123; return BAD_REQUEST; &#125; m_check_state = CHECK_STATE_HEADER; return NO_REQUEST;&#125;http_conn::HTTP_CODE http_conn::parse_content(char *text)&#123; if(m_read_idx &lt;= (m_content_length + m_checked_idx))&#123; text[m_read_idx - m_checked_idx] = &#x27;\\0&#x27;; return GET_REQUEST; &#125; return NO_REQUEST;&#125;http_conn::HTTP_CODE http_conn::process_read()&#123; LINE_STATUS line_status = LINE_OK; HTTP_CODE ret = NO_REQUEST; char *text = 0; while(((m_check_state == CHECK_STATE_CONTENT) &amp;&amp; (line_status == LINE_OK)) || ((line_status = parse_line()) == LINE_OK))&#123; text = get_line(); m_start_line = m_checked_idx; printf(&quot;got 1 http line: %s &quot;,text); switch(m_check_state)&#123; case CHECK_STATE_REQUESTLINE:&#123; ret = parse_request_line(text); if(ret == BAD_REQUEST)&#123; return BAD_REQUEST; &#125; break; &#125; case CHECK_STATE_HEADER:&#123; ret = parse_headers(text); if(ret == BAD_REQUEST)&#123; return BAD_REQUEST; &#125; else if(ret == GET_REQUEST)&#123; return do_request(); &#125; break; &#125; case CHECK_STATE_CONTENT:&#123; ret = parse_content(text); if(ret == GET_REQUEST)&#123; return do_request(); &#125; line_status = LINE_OPEN; break; &#125; default:&#123; return INTERNAL_ERROR; &#125; &#125; &#125; return NO_REQUEST;&#125;//当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性。如果目标文件存在、对所有用户可读、且不是目录，则使用mmap将其映射到内存地址m_file_address处，并告诉调用者获取文件成功http_conn::HTTP_CODE http_conn::do_request()&#123; strcpy(m_real_file,doc_root); int len = strlen(doc_root); strncpy(m_real_file + len,m_url,FILENAME_LEN - len - 1); if(stat(m_real_file,&amp;m_file_stat) &lt; 0)&#123; return NO_RESOURCE; &#125; if(!(m_file_stat.st_mode &amp; S_IROTH))&#123; return FORBIDDEN_REQUEST; &#125; if(S_ISDIR(m_file_stat.st_mode))&#123; return BAD_REQUEST; &#125; int fd = open(m_real_file,O_RDONLY); m_file_address = (char *)mmap(0,m_file_stat.st_size,PROT_READ,MAP_PRIVATE,fd,0); close(fd); return FILE_REQUEST;&#125;// 对内存映射区执行munmap操作void http_conn::unmap()&#123; if(m_file_address)&#123; munmap(m_file_address,m_file_stat.st_size); m_file_address = 0; &#125;&#125;// 写HTTP响应bool http_conn::write()&#123; int temp = 0; int bytes_have_send = 0; int bytes_to_send = m_write_idx; if(bytes_to_send == 0)&#123; modfd(m_epollfd,m_sockfd,EPOLLIN); init(); return true; &#125; while(1)&#123; temp = writev(m_sockfd,m_iv,m_iv_count); if(temp &lt;= -1)&#123; if(errno == EAGAIN)&#123; modfd(m_epollfd,m_sockfd,EPOLLOUT); return true; &#125; unmap(); return false; &#125; bytes_to_send -= temp; bytes_have_send += temp; if(bytes_to_send &lt;= bytes_have_send)&#123; unmap(); if(m_linger)&#123; init(); modfd(m_epollfd,m_sockfd,EPOLLIN); return true; &#125; else&#123; modfd(m_epollfd,m_sockfd,EPOLLIN); return false; &#125; &#125; &#125;&#125;// 向写缓冲区中写入待发送的数据bool http_conn::add_response(const char *format,...)&#123; if(m_write_idx &gt;= WRITE_BUFFER_SIZE)&#123; return false; &#125; va_list arg_list; va_start(arg_list,format); int len = vsnprintf(m_write_buf + m_write_idx,WRITE_BUFFER_SIZE - 1 - m_write_idx,format,arg_list); if(len &gt;= (WRITE_BUFFER_SIZE - 1 - m_write_idx))&#123; return false; &#125; m_write_idx += len; va_end(arg_list); return true;&#125;// 添加状态行bool http_conn::add_status_line(int status,const char *title)&#123; return add_response(&quot;%s %d %s\\r &quot;,&quot;HTTP/1.1&quot;,status,title);&#125;// 添加消息报头bool http_conn::add_headers(int content_length)&#123; add_content_length(content_length); add_linger(); add_blank_line();&#125;// 添加Content-Lengthbool http_conn::add_content_length(int content_length)&#123; return add_response(&quot;Content-Length: %d\\r &quot;,content_length);&#125;// 添加Connectionbool http_conn::add_linger()&#123; return add_response(&quot;Connection: %s\\r &quot;,(m_linger == true) ? &quot;keep-alive&quot; : &quot;close&quot;);&#125;// 添加空行bool http_conn::add_blank_line()&#123; return add_response(&quot;%s&quot;,&quot;\\r &quot;);&#125;// 添加内容bool http_conn::add_content(const char *content)&#123; return add_response(&quot;%s&quot;,content);&#125;// 根据服务器处理HTTP请求的结果，决定返回给客户端的内容bool http_conn::process_write(HTTP_CODE ret)&#123; switch(ret)&#123; case INTERNAL_ERROR:&#123; add_status_line(500,error_500_title); add_headers(strlen(error_500_form)); if(!add_content(error_500_form))&#123; return false; &#125; break; &#125; case BAD_REQUEST:&#123; add_status_line(400,error_400_title); add_headers(strlen(error_400_form)); if(!add_content(error_400_form))&#123; return false; &#125; break; &#125; case NO_RESOURCE:&#123; add_status_line(404,error_404_title); add_headers(strlen(error_404_form)); if(!add_content(error_404_form))&#123; return false; &#125; break; &#125; case FORBIDDEN_REQUEST:&#123; add_status_line(403,error_403_title); add_headers(strlen(error_403_form)); if(!add_content(error_403_form))&#123; return false; &#125; break; &#125; case FILE_REQUEST:&#123; add_status_line(200,ok_200_title); if(m_file_stat.st_size != 0)&#123; add_headers(m_file_stat.st_size); m_iv[0].iov_base = m_write_buf; m_iv[0].iov_len = m_write_idx; m_iv[1].iov_base = m_file_address; m_iv[1].iov_len = m_file_stat.st_size; m_iv_count = 2; return true; &#125; else&#123; const char *ok_string = &quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;; add_headers(strlen(ok_string)); if(!add_content(ok_string))&#123; return false; &#125; &#125; &#125; default:&#123; return false; &#125; &#125; m_iv[0].iov_base = m_write_buf; m_iv[0].iov_len = m_write_idx; m_iv_count = 1; return true;&#125;//由线程池中的工作线程调用，这是处理HTTP请求的入口函数void http_conn::process()&#123; HTTP_CODE read_ret = process_read(); if(read_ret == NO_REQUEST)&#123; modfd(m_epollfd,m_sockfd,EPOLLIN); return; &#125; bool write_ret = process_write(read_ret); if(!write_ret)&#123; close_conn(); &#125; modfd(m_epollfd,m_sockfd,EPOLLOUT);&#125; 线程池 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#ifndef THREADPOOL_H#define THREADPOOL_H#include&lt;list&gt;#include&lt;cstdio&gt;#include&lt;exception&gt;//异常处理#include&lt;pthread.h&gt;//线程#include&quot;14_2_locker.h&quot;//线程同步机制template&lt;typename T&gt;class threadpool&#123;private: int m_thread_number;//线程池中的线程数 int m_max_requests;//请求队列中允许的最大请求数 pthread_t *m_threads;//描述线程池的数组，大小为m_thread_number std::list&lt;T *&gt; m_workqueue;//请求队列 locker m_queuelocker;//保护请求队列的互斥锁 sem m_queuestat;//是否有任务需要处理 bool m_stop;//是否结束线程public: threadpool(int thread_number = 8, int max_requests = 10000); ~threadpool(); // 往请求队列中添加任务 bool append(T *request); private: static void *worker(void *arg); void run();&#125;;template&lt;typename T&gt;threadpool&lt;T&gt;::threadpool(int thread_number, int max_requests) :m_thread_number(thread_number),m_max_requests(max_requests),m_stop(false),m_threads(NULL)&#123; if((thread_number&lt;=0) || (max_requests&lt;=0))&#123; throw std::exception(); &#125; m_threads = new pthread_t[m_thread_number]; if(!m_threads)&#123; throw std::exception(); &#125; // 创建thread_number个线程，并将它们设置为脱离线程 for(int i=0;i&lt;thread_number;++i)&#123; printf(&quot;create the %dth thread &quot;,i); if(pthread_create(m_threads+i,NULL,worker,this) != 0)&#123; delete [] m_threads; throw std::exception(); &#125; if(pthread_detach(m_threads[i]))&#123; delete [] m_threads; throw std::exception(); &#125; &#125;&#125;template&lt;typename T&gt;threadpool&lt;T&gt;::~threadpool()&#123; delete [] m_threads; m_stop = true;&#125;template&lt;typename T&gt; bool threadpool&lt;T&gt;::append(T *request)&#123; m_queuelocker.lock(); if(m_workqueue.size() &gt; m_max_requests)&#123; m_queuelocker.unlock(); return false; &#125; m_workqueue.push_back(request); m_queuelocker.unlock(); m_queuestat.post(); return true;&#125;template&lt;typename T&gt;void *threadpool&lt;T&gt;::worker(void *arg)&#123; threadpool *pool = (threadpool *)arg; pool-&gt;run(); return pool;&#125;template&lt;typename T&gt;void threadpool&lt;T&gt;::run()&#123; while(!m_stop)&#123; m_queuestat.wait(); // 等待有任务的到来，信号量控制阻塞 m_queuelocker.lock(); // 上锁，确保对队列的访问是线程安全的 if (m_workqueue.empty()) &#123; // 如果任务队列为空，跳过 m_queuelocker.unlock(); continue; &#125; T* request = m_workqueue.front(); // 从队列中取任务 m_workqueue.pop_front(); // 弹出队列头部任务 m_queuelocker.unlock(); // 解锁队列，其他线程可以继续操作队列 if(!request)&#123; continue; &#125; request-&gt;process(); &#125;&#125;#endif 互斥锁 123456789101112131415161718class locker&#123;private: pthread_mutex_t m_mutex;public: locker()&#123; if(pthread_mutex_init(&amp;m_mutex,NULL) != 0) throw std::exception(); &#125; ~locker()&#123; pthread_mutex_destroy(&amp;m_mutex); &#125; bool lock()&#123; return pthread_mutex_lock(&amp;m_mutex) == 0; &#125; bool unlock()&#123; return pthread_mutex_unlock(&amp;m_mutex) == 0; &#125;&#125;; 信号量 1234567891011class sem&#123;private: sem_t m_sem; public: sem()&#123; if(sem_init(&amp;m_sem,0,0)!=0) throw std::exception(); &#125; ~sem()&#123; sem_destroy(&amp;m_sem); &#125; bool wait()&#123; return sem_wait(&amp;m_sem) == 0; &#125; bool post()&#123; return sem_post(&amp;m_sem) == 0; &#125; &#125;; 参考文章 100%弄明白5种IO模型 - 知乎 9.1 什么是零拷贝？ | 小林coding linux高性能服务器编程-游双","tags":["C++","网络编程"],"categories":["学习记录","网络编程"]},{"title":"优化理论2024试卷","path":"/posts/51543.html","content":"前言： 开卷考试，全英题，带两本原书，计算题为书上题改数据，改的很难算，例如2，3。后面题型需要快速翻书 2024试卷大概内容： 泰勒展开式 给出点（2，3）在下面函数的线性近似和二次近似 f(x)=3x2−x1x22f(x) = 3x_{2} - \\frac{x_{1}}{x_{2}^{2}} f(x)=3x2​−x22​x1​​ 起始点为（2，5），用牛顿法求解2中的极值 给四个点（x,y)，构造下面公式 P(x)=a0+a1x+a2x2+a3x3P(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3 P(x)=a0​+a1​x+a2​x2+a3​x3 不太记得了 遗传算法求解太阳能测试 U=204,165.5330−2T+10,400T−20U = \\frac{204,165.5}{330 - 2T} + \\frac{10,400}{T - 20} U=330−2T204,165.5​+T−2010,400​ （x1−1)2+(x2−1)5（x_1-1)^2+(x_2-1)^5（x1​−1)2+(x2​−1)5 subject两个不等式 约束优化问题，用Penalty Function Method求解 综合题， 多目标优化问题，给了一个图 i) 填写图中（1）-（5）的内容 ii) 不明白 iii）用粒子群算法求解上面的式子","tags":["湘潭大学","考试资料"],"categories":["湘潭大学计算机研究生课程","优化理论-肖赤心"]},{"title":"优化理论复习2","path":"/posts/48612.html","content":"Algorithms for Optimization 第十二章 多目标优化 第12章详细介绍了多目标优化（Multiobjective Optimization）的概念、方法和应用。多目标优化问题与单目标优化问题不同，它涉及多个目标函数的同时优化，通常这些目标之间是相互冲突的，无法通过单一的优化过程找到全局最优解。因此，多目标优化的核心在于找到一组Pareto最优解，这些解代表了不同目标之间的最佳权衡。以下是本章的详细讲解： 1. Pareto最优性（Pareto Optimality） Pareto最优性是多目标优化的核心概念。它描述了一种状态，即在不损害其他目标的情况下，无法进一步优化任何一个目标。 1.1 支配关系（Dominance） 在单目标优化中，两个设计点可以通过目标函数值直接比较优劣。例如，若 f(x′)&lt;f(x)f(x&#x27;) &lt; f(x)f(x′)&lt;f(x)，则 x′x&#x27;x′ 优于 xxx。 在多目标优化中，目标函数返回的是一个向量 f(x)=[f1(x),f2(x),…,fm(x)]\\mathbf{f}(x) = [f_1(x), f_2(x), \\dots, f_m(x)]f(x)=[f1​(x),f2​(x),…,fm​(x)]，每个维度对应一个目标。 定义支配关系：设计点 xxx 支配设计点 x′x&#x27;x′，当且仅当： 在所有目标上，fi(x)≤fi(x′)f_i(x) \\leq f_i(x&#x27;)fi​(x)≤fi​(x′)（即 xxx 在所有目标上不劣于 x′x&#x27;x′）； 至少在一个目标上，fi(x)&lt;fi(x′)f_i(x) &lt; f_i(x&#x27;)fi​(x)&lt;fi​(x′)（即 xxx 至少在一个目标上优于 x′x&#x27;x′）。 如果两个设计点在部分目标上互相优于对方，则它们之间存在支配模糊性（Dominance Ambiguity），无法直接比较优劣。 1.2 Pareto前沿（Pareto Frontier） Pareto前沿是所有Pareto最优解在目标空间中的集合。它代表了不同目标之间的最佳权衡。 在目标空间中，Pareto前沿通常位于边界上。对于二维目标空间，Pareto前沿是一条曲线；对于更高维空间，它是一个超曲面。 弱Pareto最优点：如果一个设计点无法在所有目标上同时被改进，则称其为弱Pareto最优点。弱Pareto最优点不一定是Pareto最优点。 1.3 Pareto前沿生成 生成Pareto前沿的简单方法是随机采样设计点，然后筛选出非支配点。然而，这种方法效率低下且无法保证Pareto前沿的平滑性。 更有效的方法包括约束法、权重法和群体方法。 2. 约束方法（Constraint Methods） 约束方法通过将多目标优化问题转化为单目标优化问题来生成Pareto前沿。 2.1 约束法（Constraint Method） 约束法通过将所有目标（除了一个）作为约束条件，将多目标优化问题转化为单目标优化问题。 例如，假设有两个目标 f1(x)f_1(x)f1​(x) 和 f2(x)f_2(x)f2​(x)，可以将 f2(x)f_2(x)f2​(x) 作为约束条件，优化 f1(x)f_1(x)f1​(x)：minimizef1(x)subject tof2(x)≤c2\\text{minimize} \\quad f_1(x) \\\\ \\text{subject to} \\quad f_2(x) \\leq c_2 minimizef1​(x)subject tof2​(x)≤c2​ 通过调整约束条件 c2c_2c2​，可以生成Pareto前沿。 2.2 词典序法（Lexicographic Method） 词典序法根据目标的重要性顺序依次进行优化。每次优化时，保留之前优化目标的最优值作为约束条件。 例如，假设有三个目标 f1(x)f_1(x)f1​(x), f2(x)f_2(x)f2​(x), f3(x)f_3(x)f3​(x)，按重要性顺序依次优化： 首先优化 f1(x)f_1(x)f1​(x)，得到最优值 y1∗y_1^*y1∗​； 然后优化 f2(x)f_2(x)f2​(x)，约束 f1(x)≤y1∗f_1(x) \\leq y_1^*f1​(x)≤y1∗​； 最后优化 f3(x)f_3(x)f3​(x)，约束 f1(x)≤y1∗f_1(x) \\leq y_1^*f1​(x)≤y1∗​ 且 f2(x)≤y2∗f_2(x) \\leq y_2^*f2​(x)≤y2∗​。 3. 权重方法（Weight Methods） 权重方法通过为每个目标分配权重，将多目标优化问题转化为单目标优化问题。这是本章的重点内容。 3.1 加权求和法（Weighted Sum Method） 加权求和法通过为每个目标分配权重 wiw_iwi​，将多目标函数转化为单目标函数：f(x)=∑i=1mwifi(x)f(x) = \\sum_{i=1}^m w_i f_i(x) f(x)=i=1∑m​wi​fi​(x) 权重 wiw_iwi​ 通常满足 wi≥0w_i \\geq 0wi​≥0 且 ∑i=1mwi=1\\sum_{i=1}^m w_i = 1∑i=1m​wi​=1。 通过调整权重，可以生成Pareto前沿。然而，加权求和法无法处理非凸的Pareto前沿。 例子： 假设我们选择权重 w1=0.5w_1 = 0.5w1​=0.5 和 w2=0.5w_2 = 0.5w2​=0.5，则单目标函数为： f(x)=0.5x2+0.5(x−2)2f(x) = 0.5 x^2 + 0.5 (x - 2)^2 f(x)=0.5x2+0.5(x−2)2 通过求解这个单目标优化问题，可以得到一个Pareto最优解。例如，对 f(x)f(x)f(x) 求导并令导数为零： dfdx=x+(x−2)=2x−2=0 ⟹ x=1\\frac{df}{dx} = x + (x - 2) = 2x - 2 = 0 \\implies x = 1 dxdf​=x+(x−2)=2x−2=0⟹x=1 因此，x=1x = 1x=1 是一个Pareto最优解。 3.2 目标规划（Goal Programming） 目标规划通过最小化目标函数值与目标点之间的 LpL_pLp​ 范数来生成Pareto前沿：minimize∥f(x)−ygoal∥p\\text{minimize} \\quad \\| \\mathbf{f}(x) - \\mathbf{y}^{\\text{goal}} \\|_p minimize∥f(x)−ygoal∥p​ 目标点通常是理想点（utopia point），即每个目标的最优值。 ppp 是范数的阶数，用于衡量目标函数值与目标点之间的偏差。常见的取值包括： p=1p = 1p=1：最小化总偏差（绝对值和）； p=2p = 2p=2：最小化几何距离（欧几里得距离）； p→∞p \\to \\inftyp→∞：最小化最大偏差。 例子： 假设目标点为 ygoal=[0,0]\\mathbf{y}^{\\text{goal}} = [0, 0]ygoal=[0,0]，选择 p=2p = 2p=2，则目标规划问题为： minimizex2+(x−2)2\\text{minimize} \\quad \\sqrt{x^2 + (x - 2)^2} minimizex2+(x−2)2​ 通过求解这个优化问题，可以得到一个Pareto最优解。 3.3 加权指数求和法（Weighted Exponential Sum） 加权指数求和法结合了目标规划和加权求和法，通过引入指数权重来生成Pareto前沿：f(x)=∑i=1mwi(fi(x)−yigoal)pf(x) = \\sum_{i=1}^m w_i \\left( f_i(x) - y_i^{\\text{goal}} \\right)^p f(x)=i=1∑m​wi​(fi​(x)−yigoal​)p ppp 是指数权重的幂次，用于调整目标函数值与目标点之间偏差的惩罚强度。较大的 ppp 会更关注最大偏差。 例子： 假设目标点为 ygoal=[0,0]\\mathbf{y}^{\\text{goal}} = [0, 0]ygoal=[0,0]，选择 p=2p = 2p=2，权重 w1=0.5w_1 = 0.5w1​=0.5 和 w2=0.5w_2 = 0.5w2​=0.5，则加权指数求和法为： f(x)=0.5(x2−0)2+0.5((x−2)2−0)2f(x) = 0.5 \\left( x^2 - 0 \\right)^2 + 0.5 \\left( (x - 2)^2 - 0 \\right)^2 f(x)=0.5(x2−0)2+0.5((x−2)2−0)2 简化后： f(x)=0.5x4+0.5(x−2)4f(x) = 0.5 x^4 + 0.5 (x - 2)^4 f(x)=0.5x4+0.5(x−2)4 3.4 加权最小最大法（Weighted Min-Max Method） 加权最小最大法通过最小化目标函数值与目标点之间的最大偏差来生成Pareto前沿：f(x)=max⁡i[wi(fi(x)−yigoal)]f(x) = \\max_i \\left[ w_i \\left( f_i(x) - y_i^{\\text{goal}} \\right) \\right] f(x)=imax​[wi​(fi​(x)−yigoal​)] 这种方法可以处理非凸的Pareto前沿。 例子： 假设目标点为 ygoal=[0,0]\\mathbf{y}^{\\text{goal}} = [0, 0]ygoal=[0,0]，选择 w1=0.5w_1 = 0.5w1​=0.5 和 w2=0.5w_2 = 0.5w2​=0.5，则加权最小最大法为： f(x)=max⁡[0.5x2,0.5(x−2)2]f(x) = \\max \\left[ 0.5 x^2, 0.5 (x - 2)^2 \\right] f(x)=max[0.5x2,0.5(x−2)2] 通过求解这个优化问题，可以得到一个Pareto最优解。 4. 多目标群体方法（Multiobjective Population Methods） 群体方法（如遗传算法）也可以用于多目标优化。通过调整群体方法，可以生成覆盖Pareto前沿的解集。 4.1 子群体（Subpopulations） 群体方法可以将群体划分为多个子群体，每个子群体针对不同的目标进行优化。通过子群体之间的交叉和变异，可以生成多样化的解集。 4.2 非支配排序（Nondomination Ranking） 非支配排序通过将群体中的个体按照非支配关系进行排序，生成Pareto前沿的近似解。 4.3 Pareto过滤器（Pareto Filters） Pareto过滤器用于在群体方法中维护一个近似Pareto前沿的解集。通过不断更新过滤器，可以确保群体方法生成的解集覆盖Pareto前沿。 4.4 小生境技术（Niche Techniques） 小生境技术通过惩罚目标空间中过于集中的个体，鼓励群体方法生成均匀分布的Pareto前沿解集。 5. 偏好引导（Preference Elicitation） 偏好引导通过专家的偏好信息，推断出合适的权重向量，从而将多目标优化问题转化为单目标优化问题。 5.1 模型识别（Model Identification） 通过专家的偏好信息，可以识别出合适的权重向量。常见的偏好引导方法包括二元偏好查询和排序查询。 5.2 配对查询选择（Paired Query Selection） 配对查询选择通过选择信息量最大的查询对，快速缩小权重向量的可行域。 5.3 设计选择（Design Selection） 设计选择通过最小化最坏情况下的目标值或最小化最大遗憾值，选择最终的设计方案。 6. 总结 多目标优化涉及多个目标之间的权衡，通常没有唯一的最优解。 Pareto前沿代表了不同目标之间的最佳权衡。 通过约束法或权重法，可以将多目标优化问题转化为单目标优化问题。 群体方法可以生成覆盖Pareto前沿的解集。 通过专家的偏好信息，可以推断出合适的权重向量，从而选择最优设计方案。 第十四章 代理模型 1. 代理模型的拟合 核心思想：代理模型 f^\\hat{f}f^​ 通过参数 θ\\thetaθ 来模拟真实的目标函数 fff。我们通过调整参数 θ\\thetaθ 来最小化模型预测值 y^\\hat{\\mathbf{y}}y^​ 和真实值 y\\mathbf{y}y 之间的差异，通常使用 LpL_pLp​ 范数（如 L2L_2L2​ 范数，即最小化均方误差）。 例子： 假设我们有 3 个设计点 X={x(1),x(2),x(3)}X = \\{\\mathbf{x}^{(1)}, \\mathbf{x}^{(2)}, \\mathbf{x}^{(3)}\\}X={x(1),x(2),x(3)}，对应的函数评估值为 y={y(1),y(2),y(3)}\\mathbf{y} = \\{y^{(1)}, y^{(2)}, y^{(3)}\\}y={y(1),y(2),y(3)}。代理模型的目标是通过调整参数 θ\\thetaθ，使得模型的预测值 y^={f^θ(x(1)),f^θ(x(2)),f^θ(x(3))}\\hat{\\mathbf{y}} = \\{\\hat{f}_{\\theta}(\\mathbf{x}^{(1)}), \\hat{f}_{\\theta}(\\mathbf{x}^{(2)}), \\hat{f}_{\\theta}(\\mathbf{x}^{(3)})\\}y^​={f^​θ​(x(1)),f^​θ​(x(2)),f^​θ​(x(3))} 尽可能接近真实值 y\\mathbf{y}y。 2. 线性模型 核心思想：线性模型是最简单的代理模型，形式为 f^=w0+w⊤x\\hat{f} = w_0 + \\mathbf{w}^\\top \\mathbf{x}f^​=w0​+w⊤x。对于 nnn 维设计空间，线性模型有 n+1n+1n+1 个参数，因此至少需要 n+1n+1n+1 个样本来拟合。 例子： 假设我们有一个二维设计空间，设计点为 X={(1,2),(2,3),(3,4)}X = \\{(1, 2), (2, 3), (3, 4)\\}X={(1,2),(2,3),(3,4)}，对应的函数评估值为 y={3,5,7}\\mathbf{y} = \\{3, 5, 7\\}y={3,5,7}。我们可以构建设计矩阵 X\\mathbf{X}X 并求解线性回归问题来找到最优参数 θ\\thetaθ。 设计矩阵： X=[112123134]\\mathbf{X} = \\begin{bmatrix} 1 &amp; 1 &amp; 2 \\\\ 1 &amp; 2 &amp; 3 \\\\ 1 &amp; 3 &amp; 4 \\end{bmatrix} X=⎣⎢⎡​111​123​234​⎦⎥⎤​ 通过最小二乘法，我们可以求解 θ=(X⊤X)−1X⊤y\\theta = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y}θ=(X⊤X)−1X⊤y，得到最优参数。 3. 基函数 核心思想：线性模型是基函数的一种特例。更一般的形式是线性组合基函数： f^(x)=∑i=1qθibi(x)\\hat{f}(x) = \\sum_{i=1}^q \\theta_i b_i(x) f^​(x)=i=1∑q​θi​bi​(x) 其中 bi(x)b_i(x)bi​(x) 是基函数。常见的基函数包括多项式基函数、正弦基函数和径向基函数。 3.1 多项式基函数 核心思想：多项式基函数由设计向量的各分量幂次组成。通过泰勒级数展开，任何无限可微函数都可以用足够高阶的多项式近似。 例子： 在一维情况下，一个 kkk 次多项式模型的形式为： f^(x)=θ0+θ1x+θ2x2+⋯+θkxk\\hat{f}(x) = \\theta_0 + \\theta_1 x + \\theta_2 x^2 + \\cdots + \\theta_k x^k f^​(x)=θ0​+θ1​x+θ2​x2+⋯+θk​xk 假设我们有 4 个设计点 X={1,2,3,4}X = \\{1, 2, 3, 4\\}X={1,2,3,4}，对应的函数评估值为 y={0,5,4,6}\\mathbf{y} = \\{0, 5, 4, 6\\}y={0,5,4,6}。我们可以通过多项式基函数拟合这些数据。 3.2 正弦基函数 核心思想：任何有限域上的连续函数都可以用无限的正弦基函数表示。傅里叶级数可以用于构造这些基函数。 例子： 在一维情况下，傅里叶级数的基函数为： b0(x)=1/2,bi(sin)(x)=sin⁡(2πixb−a),bi(cos)(x)=cos⁡(2πixb−a)b_0(x) = 1/2, \\quad b_i^{(\\text{sin})}(x) = \\sin\\left(\\frac{2\\pi i x}{b - a}\\right), \\quad b_i^{(\\text{cos})}(x) = \\cos\\left(\\frac{2\\pi i x}{b - a}\\right) b0​(x)=1/2,bi(sin)​(x)=sin(b−a2πix​),bi(cos)​(x)=cos(b−a2πix​) 假设我们有一个函数 f(x)=sin⁡(2x)cos⁡(10x)f(x) = \\sin(2x) \\cos(10x)f(x)=sin(2x)cos(10x)，我们可以使用正弦基函数来拟合这个函数。 3.3 径向基函数 核心思想：径向基函数仅依赖于点与中心点的距离。常见的径向基函数包括线性、立方、薄板样条、高斯、多二次和逆多二次函数。 例子： 假设我们有设计点 X={(1,2),(2,3),(3,4)}X = \\{(1, 2), (2, 3), (3, 4)\\}X={(1,2),(2,3),(3,4)}，我们可以使用这些点作为中心点构建径向基函数 bi(x)=ψ(∥x−x(i)∥)b_i(x) = \\psi(\\|x - x^{(i)}\\|)bi​(x)=ψ(∥x−x(i)∥)，其中 ψ\\psiψ 是径向基函数（如高斯函数 ψ(r)=e−r2/2σ2\\psi(r) = e^{-r^2/2\\sigma^2}ψ(r)=e−r2/2σ2）。 4. 拟合噪声目标函数 核心思想：当目标函数评估存在噪声时，复杂的模型可能会过度拟合噪声数据。为了获得更平滑的拟合，可以在回归问题中加入正则化项，如 L2L_2L2​ 正则化，以偏好权重较低的解决方案。 例子： 假设我们有带噪声的目标函数评估值 y\\mathbf{y}y，我们可以通过加入正则化项 λ∥θ∥22\\lambda \\|\\theta\\|_2^2λ∥θ∥22​ 来获得更平滑的拟合。最优参数向量可以通过 θ=(B⊤B+λI)−1B⊤y\\theta = (\\mathbf{B}^\\top \\mathbf{B} + \\lambda \\mathbf{I})^{-1} \\mathbf{B}^\\top \\mathbf{y}θ=(B⊤B+λI)−1B⊤y 计算。 5. 模型选择 核心思想：模型选择的目标是最小化泛化误差，即模型在整个设计空间上的预测误差。常见的估计泛化误差的方法包括留出法、交叉验证和自助法。 5.1 留出法 核心思想：将数据分为训练集和测试集，训练集用于拟合模型，测试集用于估计泛化误差。 例子： 假设我们有 10 个数据点，我们可以将其中 8 个点作为训练集，2 个点作为测试集。通过多次随机划分，我们可以获得泛化误差的估计。 5.2 交叉验证 核心思想：将数据分为 kkk 个子集，每次使用 k−1k-1k−1 个子集训练模型，剩下的子集用于估计泛化误差。 例子： 假设我们有 10 个数据点，我们可以进行 5 折交叉验证，每次使用 8 个点训练模型，2 个点测试模型。通过 5 次不同的划分，我们可以获得泛化误差的估计。 5.3 自助法 核心思想：通过有放回地采样生成多个训练集，每个训练集用于拟合模型，并在原始数据集上评估泛化误差。 例子： 假设我们有 10 个数据点，我们可以生成 10 个自助样本，每个样本包含 10 个点（可能有重复）。通过在这些样本上训练模型并在原始数据上测试，我们可以获得泛化误差的估计。 6. 总结 代理模型：是目标函数的近似，可以替代真实的目标函数进行优化。 基函数：许多代理模型可以用基函数的线性组合表示。 模型选择：涉及偏差-方差权衡，低复杂度模型可能无法捕捉重要趋势，而高复杂度模型可能过度拟合噪声。 泛化误差：可以通过留出法、交叉验证和自助法等方法进行估计。 练习 : 1：推导线性回归问题的正规方程 问题：推导线性回归问题的最优解，即正规方程。 解答： 线性回归问题的目标是最小化均方误差： minimizeθ∥y−Xθ∥22minimize_{\\theta} \\|\\mathbf{y} - \\mathbf{X}\\theta\\|_2^2 minimizeθ​∥y−Xθ∥22​ 其中，X\\mathbf{X}X 是设计矩阵，y\\mathbf{y}y 是目标值向量，θ\\thetaθ 是参数向量。 将目标函数展开： ∥y−Xθ∥22=(y−Xθ)⊤(y−Xθ)\\|\\mathbf{y} - \\mathbf{X}\\theta\\|_2^2 = (\\mathbf{y} - \\mathbf{X}\\theta)^\\top (\\mathbf{y} - \\mathbf{X}\\theta) ∥y−Xθ∥22​=(y−Xθ)⊤(y−Xθ) 对 θ\\thetaθ 求梯度并设为零： ∇θ(y−Xθ)⊤(y−Xθ)=−2X⊤(y−Xθ)=0 abla_\\theta (\\mathbf{y} - \\mathbf{X}\\theta)^\\top (\\mathbf{y} - \\mathbf{X}\\theta) = -2\\mathbf{X}^\\top (\\mathbf{y} - \\mathbf{X}\\theta) = 0 ∇θ​(y−Xθ)⊤(y−Xθ)=−2X⊤(y−Xθ)=0 整理得到正规方程： X⊤Xθ=X⊤y\\mathbf{X}^\\top \\mathbf{X} \\theta = \\mathbf{X}^\\top \\mathbf{y} X⊤Xθ=X⊤y 如果 X⊤X\\mathbf{X}^\\top \\mathbf{X}X⊤X 可逆，则最优解为： θ=(X⊤X)−1X⊤y\\theta = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y} θ=(X⊤X)−1X⊤y 2：何时使用多项式模型与线性回归模型 问题：讨论何时使用多项式模型与线性回归模型。 解答： 线性回归模型：适用于目标函数与输入变量之间存在线性关系的情况。线性模型简单且计算成本低，但无法捕捉非线性关系。 多项式模型：适用于目标函数与输入变量之间存在非线性关系的情况。通过引入高阶项，多项式模型可以拟合更复杂的函数，但容易过拟合，尤其是在数据量较少时。 选择依据： 数据量：如果数据量较少，优先选择线性模型，避免过拟合。 问题复杂度：如果目标函数明显是非线性的，可以使用多项式模型。 计算资源：多项式模型的计算成本较高，尤其是在高维情况下。 3：为什么线性回归问题有时需要使用优化技术而不是解析解 问题：解释为什么线性回归问题有时需要使用优化技术而不是解析解。 解答： 线性回归问题的解析解为： θ=(X⊤X)−1X⊤y\\theta = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y} θ=(X⊤X)−1X⊤y 但在以下情况下，解析解可能不适用： 矩阵不可逆：当 X⊤X\\mathbf{X}^\\top \\mathbf{X}X⊤X 不可逆时，解析解无法计算。这种情况可能发生在数据点线性相关或数据量少于特征数时。 计算复杂度高：当设计矩阵 X\\mathbf{X}X 非常大时，计算 (X⊤X)−1(\\mathbf{X}^\\top \\mathbf{X})^{-1}(X⊤X)−1 的复杂度很高，甚至不可行。 数值稳定性：当 X⊤X\\mathbf{X}^\\top \\mathbf{X}X⊤X 接近奇异矩阵时，解析解可能数值不稳定。 在这些情况下，可以使用优化技术（如梯度下降法）来求解线性回归问题，避免直接计算逆矩阵。 4：计算留一法交叉验证的均方误差 问题：假设我们在四个点 x={1,2,3,4}x = \\{1, 2, 3, 4\\}x={1,2,3,4} 上评估目标函数，得到 y={0,5,4,6}y = \\{0, 5, 4, 6\\}y={0,5,4,6}。我们拟合多项式模型 f^(x)=∑i=0kθixi\\hat{f}(x) = \\sum_{i=0}^k \\theta_i x^if^​(x)=∑i=0k​θi​xi，计算 kkk 从 0 到 4 时的留一法交叉验证均方误差，并选择最佳的 kkk 和 θ\\thetaθ。 解答： 留一法交叉验证的步骤如下： 对于每个 kkk，依次将每个数据点作为测试集，其余数据点作为训练集。 在训练集上拟合多项式模型，计算测试集上的预测误差。 对所有测试集的误差取平均，得到均方误差（MSE）。 计算过程： 以 k=1k = 1k=1 为例： 测试集为 x=1x = 1x=1，训练集为 x={2,3,4}x = \\{2, 3, 4\\}x={2,3,4}。 在训练集上拟合线性模型 f^(x)=θ0+θ1x\\hat{f}(x) = \\theta_0 + \\theta_1 xf^​(x)=θ0​+θ1​x。 计算测试集上的预测误差 (y−f^(x))2(y - \\hat{f}(x))^2(y−f^​(x))2。 重复上述过程，计算 k=0,1,2,3,4k = 0, 1, 2, 3, 4k=0,1,2,3,4 时的 MSE。 结果： 通过计算，可以得到不同 kkk 值下的 MSE。选择 MSE 最小的 kkk 值作为最佳模型。 最佳 kkk 和 θ\\thetaθ： 假设 k=2k = 2k=2 时 MSE 最小，则最佳模型为： f^(x)=θ0+θ1x+θ2x2\\hat{f}(x) = \\theta_0 + \\theta_1 x + \\theta_2 x^2 f^​(x)=θ0​+θ1​x+θ2​x2 通过最小二乘法拟合训练数据，得到最优参数 θ\\thetaθ。 第十五章 概率代理模型 1. 高斯分布（Gaussian Distribution） 高斯分布是高斯过程的基础。多元高斯分布由均值向量 μ\\muμ 和协方差矩阵 Σ\\SigmaΣ 参数化，其概率密度函数为： N(x∣μ,Σ)=(2π)−n/2∣Σ∣−1/2exp⁡(−12(x−μ)⊤Σ−1(x−μ))\\mathcal{N}({\\bf x}\\mid\\mu,\\Sigma)=(2\\pi)^{-n/2}|\\Sigma|^{-1/2}\\exp\\left(-\\frac{1}{2}({\\bf x}-\\mu)^{\\top}\\Sigma^{-1}({\\bf x}-\\mu)\\right) N(x∣μ,Σ)=(2π)−n/2∣Σ∣−1/2exp(−21​(x−μ)⊤Σ−1(x−μ)) 关键性质： 边际分布：多元高斯分布的边际分布仍然是高斯分布。 条件分布：给定部分变量的值，剩余变量的条件分布也是高斯分布。 例15.1：多元高斯的边际分布和条件分布 问题描述： 假设我们有一个二维高斯分布： [x1x2]∼N([01],[3112])\\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} \\sim \\mathcal{N}\\left( \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, \\begin{bmatrix} 3 &amp; 1 \\\\ 1 &amp; 2 \\end{bmatrix} \\right) [x1​x2​​]∼N([01​],[31​12​]) 计算： x1x_1x1​ 和 x2x_2x2​ 的边际分布。 在 x2=2x_2 = 2x2​=2 的条件下，x1x_1x1​ 的条件分布。 解答： 边际分布： x1x_1x1​ 的边际分布为：x1∼N(0,3)x_1 \\sim \\mathcal{N}(0, 3) x1​∼N(0,3) x2x_2x2​ 的边际分布为：x2∼N(1,2)x_2 \\sim \\mathcal{N}(1, 2) x2​∼N(1,2) 条件分布： 条件分布的均值和协方差通过公式计算：μx1∣x2=2=0+1⋅2−1⋅(2−1)=0.5\\mu_{x_1|x_2=2} = 0 + 1 \\cdot 2^{-1} \\cdot (2 - 1) = 0.5 μx1​∣x2​=2​=0+1⋅2−1⋅(2−1)=0.5 Σx1∣x2=2=3−1⋅2−1⋅1=2.5\\Sigma_{x_1|x_2=2} = 3 - 1 \\cdot 2^{-1} \\cdot 1 = 2.5 Σx1​∣x2​=2​=3−1⋅2−1⋅1=2.5 因此，条件分布为：x1∣(x2=2)∼N(0.5,2.5)x_1 | (x_2 = 2) \\sim \\mathcal{N}(0.5, 2.5) x1​∣(x2​=2)∼N(0.5,2.5) 意义： 这个例子展示了如何从联合高斯分布中提取边际分布和条件分布，为后续高斯过程的预测奠定了基础。 2. 高斯过程（Gaussian Processes） 高斯过程是函数的概率分布。对于任何有限的设计点集合 {x(1),…,x(m)}\\{x^{(1)}, \\dots, x^{(m)}\\}{x(1),…,x(m)}，其对应的函数值 {y1,…,ym}\\{y_1, \\dots, y_m\\}{y1​,…,ym​} 服从多元高斯分布： [y1⋮ym]∼N([m(x(1))⋮m(x(m))],[k(x(1),x(1))⋯k(x(1),x(m))⋮⋱⋮k(x(m),x(1))⋯k(x(m),x(m))])\\begin{bmatrix} y_1 \\\\ \\vdots \\\\ y_m \\end{bmatrix} \\sim \\mathcal{N}\\left( \\begin{bmatrix} m(x^{(1)}) \\\\ \\vdots \\\\ m(x^{(m)}) \\end{bmatrix}, \\begin{bmatrix} k(x^{(1)}, x^{(1)}) &amp; \\cdots &amp; k(x^{(1)}, x^{(m)}) \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ k(x^{(m)}, x^{(1)}) &amp; \\cdots &amp; k(x^{(m)}, x^{(m)}) \\end{bmatrix} \\right) ⎣⎢⎢⎡​y1​⋮ym​​⎦⎥⎥⎤​∼N⎝⎜⎜⎛​⎣⎢⎢⎡​m(x(1))⋮m(x(m))​⎦⎥⎥⎤​,⎣⎢⎢⎡​k(x(1),x(1))⋮k(x(m),x(1))​⋯⋱⋯​k(x(1),x(m))⋮k(x(m),x(m))​⎦⎥⎥⎤​⎠⎟⎟⎞​ 其中： m(x)m(x)m(x) 是均值函数，通常假设为零均值。 k(x,x′)k(x, x&#x27;)k(x,x′) 是核函数（协方差函数），控制函数的平滑性。 常用核函数： 平方指数核（Squared Exponential Kernel）：k(x,x′)=exp⁡(−(x−x′)22ℓ2)k(x, x&#x27;) = \\exp\\left(-\\frac{(x - x&#x27;)^2}{2\\ell^2}\\right) k(x,x′)=exp(−2ℓ2(x−x′)2​) 其中，ℓ\\ellℓ 是长度尺度参数，控制函数的平滑程度。 Matern核：适用于非平滑函数。 线性核、多项式核等。 例15.2：高斯过程的核函数推导 问题描述： 假设我们使用平方指数核： kff(x,x′)=exp⁡(−12∥x−x′∥2)k_{ff}(x, x&#x27;) = \\exp\\left(-\\frac{1}{2}\\|x - x&#x27;\\|^2\\right) kff​(x,x′)=exp(−21​∥x−x′∥2) 推导其他核函数 kf∇(x,x′)k_{f abla}(x, x&#x27;)kf∇​(x,x′)、k∇f(x,x′)k_{ abla f}(x, x&#x27;)k∇f​(x,x′) 和 k∇∇(x,x′)k_{ abla abla}(x, x&#x27;)k∇∇​(x,x′)。 解答： kf∇(x,x′)k_{f abla}(x, x&#x27;)kf∇​(x,x′) 是函数值与梯度的协方差：kf∇(x,x′)=∂∂x′kff(x,x′)=−(x−x′)exp⁡(−12∥x−x′∥2)k_{f abla}(x, x&#x27;) = \\frac{\\partial}{\\partial x&#x27;} k_{ff}(x, x&#x27;) = -(x - x&#x27;) \\exp\\left(-\\frac{1}{2}\\|x - x&#x27;\\|^2\\right) kf∇​(x,x′)=∂x′∂​kff​(x,x′)=−(x−x′)exp(−21​∥x−x′∥2) k∇∇(x,x′)k_{ abla abla}(x, x&#x27;)k∇∇​(x,x′) 是梯度与梯度的协方差：k∇∇(x,x′)=∂2∂x∂x′kff(x,x′)=((x−x′)2−1)exp⁡(−12∥x−x′∥2)k_{ abla abla}(x, x&#x27;) = \\frac{\\partial^2}{\\partial x \\partial x&#x27;} k_{ff}(x, x&#x27;) = \\left((x - x&#x27;)^2 - 1\\right) \\exp\\left(-\\frac{1}{2}\\|x - x&#x27;\\|^2\\right) k∇∇​(x,x′)=∂x∂x′∂2​kff​(x,x′)=((x−x′)2−1)exp(−21​∥x−x′∥2) 意义： 这个例子展示了如何从基本核函数推导出高阶核函数，为引入梯度信息奠定了基础。 3. 梯度信息（Gradient Measurements） 高斯过程可以扩展到包含梯度信息的情况。假设我们有函数值 yyy 和梯度 ∇y abla y∇y，联合分布为： [y∇y]∼N([mfm∇],[KffKf∇K∇fK∇∇])\\begin{bmatrix} y \\\\ abla y \\end{bmatrix} \\sim \\mathcal{N}\\left( \\begin{bmatrix} \\mathbf{m}_f \\\\ \\mathbf{m}_ abla \\end{bmatrix}, \\begin{bmatrix} \\mathbf{K}_{ff} &amp; \\mathbf{K}_{f abla} \\\\ \\mathbf{K}_{ abla f} &amp; \\mathbf{K}_{ abla abla} \\end{bmatrix} \\right) [y∇y​]∼N([mf​m∇​​],[Kff​K∇f​​Kf∇​K∇∇​​]) 例15.3：构建包含梯度信息的协方差矩阵 问题描述： 假设我们在两个点 x(1)x^{(1)}x(1) 和 x(2)x^{(2)}x(2) 处评估了函数值和梯度，现在需要预测新点 x^\\hat{x}x^ 处的函数值。 解答： 构建联合分布的协方差矩阵：[kff(x^,x^)kff(x^,x(1))kff(x^,x(2))kf∇(x^,x(1))kf∇(x^,x(2))kff(x(1),x^)kff(x(1),x(1))kff(x(1),x(2))kf∇(x(1),x(1))kf∇(x(1),x(2))⋮⋮⋮⋮⋮]\\begin{bmatrix} k_{ff}(\\hat{x}, \\hat{x}) &amp; k_{ff}(\\hat{x}, x^{(1)}) &amp; k_{ff}(\\hat{x}, x^{(2)}) &amp; k_{f abla}(\\hat{x}, x^{(1)}) &amp; k_{f abla}(\\hat{x}, x^{(2)}) \\\\ k_{ff}(x^{(1)}, \\hat{x}) &amp; k_{ff}(x^{(1)}, x^{(1)}) &amp; k_{ff}(x^{(1)}, x^{(2)}) &amp; k_{f abla}(x^{(1)}, x^{(1)}) &amp; k_{f abla}(x^{(1)}, x^{(2)}) \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\end{bmatrix} ⎣⎢⎢⎡​kff​(x^,x^)kff​(x(1),x^)⋮​kff​(x^,x(1))kff​(x(1),x(1))⋮​kff​(x^,x(2))kff​(x(1),x(2))⋮​kf∇​(x^,x(1))kf∇​(x(1),x(1))⋮​kf∇​(x^,x(2))kf∇​(x(1),x(2))⋮​⎦⎥⎥⎤​ 使用条件分布公式计算预测值。 意义： 这个例子展示了如何利用梯度信息构建更精确的高斯过程模型。 4. 噪声测量（Noisy Measurements） 在实际应用中，函数评估可能包含噪声。我们可以将噪声建模为 y=f(x)+zy = f(x) + zy=f(x)+z，其中 zzz 是零均值的高斯噪声。通过引入噪声方差 vvv，我们可以调整预测的不确定性。 噪声情况下的联合分布： [y^y]∼N([m(X∗)m(X)],[K(X∗,X∗)K(X∗,X)K(X,X∗)K(X,X)+vI])\\begin{bmatrix} \\hat{\\mathbf{y}} \\\\ \\mathbf{y} \\end{bmatrix} \\sim \\mathcal{N}\\left( \\begin{bmatrix} \\mathbf{m}(X^*) \\\\ \\mathbf{m}(X) \\end{bmatrix}, \\begin{bmatrix} \\mathbf{K}(X^*, X^*) &amp; \\mathbf{K}(X^*, X) \\\\ \\mathbf{K}(X, X^*) &amp; \\mathbf{K}(X, X) + v\\mathbf{I} \\end{bmatrix} \\right) [y^​y​]∼N([m(X∗)m(X)​],[K(X∗,X∗)K(X,X∗)​K(X∗,X)K(X,X)+vI​]) 5. 习题讲解 习题1：高斯过程的复杂性 问题：高斯过程在优化过程中如何随着样本的增加而增加复杂性？ 解答：高斯过程的计算复杂度主要来自于协方差矩阵的求逆操作，其复杂度为 O(n3)O(n^3)O(n3)，其中 nnn 是样本数量。随着样本的增加，计算量会显著增加。 习题2：计算复杂度 问题：高斯过程预测的计算复杂度如何随数据点的增加而变化？ 解答：预测的计算复杂度为 O(n2)O(n^2)O(n2)，其中 nnn 是数据点的数量。 习题3：高斯过程的预测 问题：考虑函数 f(x)=sin⁡(x)/(x2+1)f(x) = \\sin(x)/(x^2 + 1)f(x)=sin(x)/(x2+1)，使用高斯过程预测其值，并计算95%置信区间。 解答：通过高斯过程的预测公式，可以计算出预测值和置信区间。 6. 总结 高斯过程是函数的概率分布，能够量化预测的不确定性。 核函数的选择影响函数的平滑性。 通过引入梯度信息和噪声测量，可以进一步提高模型的预测精度。 例15.1、15.2和15.3分别展示了边际分布、核函数推导和梯度信息的应用。","tags":["湘潭大学","考试资料"],"categories":["湘潭大学计算机研究生课程","优化理论-肖赤心"]},{"title":"优化理论复习1","path":"/posts/48609.html","content":"OPTIMIZATION Algorithms and Applications 二次型转换 1. 将函数转换为矩阵形式 给定函数： f(x1,x2)=6x12−6x1x2+2x22−x1−2x2f(x_1, x_2) = 6x_1^2 - 6x_1x_2 + 2x_2^2 - x_1 - 2x_2 f(x1​,x2​)=6x12​−6x1​x2​+2x22​−x1​−2x2​ 将其表示为矩阵形式： f(x1,x2)=12XTAX+BTXf(x_1, x_2) = \\frac{1}{2} X^T A X + B^T X f(x1​,x2​)=21​XTAX+BTX 其中： X=[x1x2],A=[12−6−64],B=[−1−2]X = \\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix}, \\quad A = \\begin{bmatrix} 12 &amp; -6 \\\\ -6 &amp; 4 \\end{bmatrix}, \\quad B = \\begin{bmatrix} -1 \\\\ -2 \\end{bmatrix} X=[x1​x2​​],A=[12−6​−64​],B=[−1−2​] 2. 对角化矩阵 AAA 2.1 计算特征值 解特征方程 det⁡(A−λI)=0\\det(A - \\lambda I) = 0det(A−λI)=0： det⁡[12−λ−6−64−λ]=(12−λ)(4−λ)−(−6)2=λ2−16λ+12=0\\det \\begin{bmatrix} 12 - \\lambda &amp; -6 \\\\ -6 &amp; 4 - \\lambda \\end{bmatrix} = (12 - \\lambda)(4 - \\lambda) - (-6)^2 = \\lambda^2 - 16\\lambda + 12 = 0 det[12−λ−6​−64−λ​]=(12−λ)(4−λ)−(−6)2=λ2−16λ+12=0 解得特征值： λ1=8+213,λ2=8−213\\lambda_1 = 8 + 2\\sqrt{13}, \\quad \\lambda_2 = 8 - 2\\sqrt{13} λ1​=8+213​,λ2​=8−213​ 2.2 计算特征向量 对于 λ1=8+213\\lambda_1 = 8 + 2\\sqrt{13}λ1​=8+213​： 解方程 (A−λ1I)v=0(A - \\lambda_1 I)v = 0(A−λ1​I)v=0： [12−(8+213)−6−64−(8+213)][v1v2]=0\\begin{bmatrix} 12 - (8 + 2\\sqrt{13}) &amp; -6 \\\\ -6 &amp; 4 - (8 + 2\\sqrt{13}) \\end{bmatrix} \\begin{bmatrix} v_1 \\\\ v_2 \\end{bmatrix} = 0 [12−(8+213​)−6​−64−(8+213​)​][v1​v2​​]=0 解得特征向量： v1=[14+2136]v_1 = \\begin{bmatrix} 1 \\\\ \\frac{4 + 2\\sqrt{13}}{6} \\end{bmatrix} v1​=[164+213​​​] 对于 λ2=8−213\\lambda_2 = 8 - 2\\sqrt{13}λ2​=8−213​： 解方程 (A−λ2I)v=0(A - \\lambda_2 I)v = 0(A−λ2​I)v=0： [12−(8−213)−6−64−(8−213)][v1v2]=0\\begin{bmatrix} 12 - (8 - 2\\sqrt{13}) &amp; -6 \\\\ -6 &amp; 4 - (8 - 2\\sqrt{13}) \\end{bmatrix} \\begin{bmatrix} v_1 \\\\ v_2 \\end{bmatrix} = 0 [12−(8−213​)−6​−64−(8−213​)​][v1​v2​​]=0 解得特征向量： v2=[14−2136]v_2 = \\begin{bmatrix} 1 \\\\ \\frac{4 - 2\\sqrt{13}}{6} \\end{bmatrix} v2​=[164−213​​​] 2.3 归一化特征向量 将特征向量归一化为单位向量： 对于 v1v_1v1​： ∥v1∥=12+(4+2136)2\\|v_1\\| = \\sqrt{1^2 + \\left(\\frac{4 + 2\\sqrt{13}}{6}\\right)^2} ∥v1​∥=12+(64+213​​)2​ 归一化后的特征向量： u1=v1∥v1∥u_1 = \\frac{v_1}{\\|v_1\\|} u1​=∥v1​∥v1​​ 对于 v2v_2v2​： ∥v2∥=12+(4−2136)2\\|v_2\\| = \\sqrt{1^2 + \\left(\\frac{4 - 2\\sqrt{13}}{6}\\right)^2} ∥v2​∥=12+(64−213​​)2​ 归一化后的特征向量： u2=v2∥v2∥u_2 = \\frac{v_2}{\\|v_2\\|} u2​=∥v2​∥v2​​ 2.4 对角化矩阵 将归一化后的特征向量组成矩阵 PPP： P=[u1u2]P = \\begin{bmatrix} u_1 &amp; u_2 \\end{bmatrix} P=[u1​​u2​​] 对角矩阵 DDD 为： D=[8+213008−213]D = \\begin{bmatrix} 8 + 2\\sqrt{13} &amp; 0 \\\\ 0 &amp; 8 - 2\\sqrt{13} \\end{bmatrix} D=[8+213​0​08−213​​] 因此，矩阵 AAA 可以表示为： A=PDP−1A = P D P^{-1} A=PDP−1 3. 绘制对角化后的矩阵 DDD 的等高线图像 3.1 等高线的类型 矩阵 DDD 的等高线方程为： 12XTDX=常数\\frac{1}{2} X^T D X = \\text{常数} 21​XTDX=常数 展开后为： 12((8+213)x12+(8−213)x22)=常数\\frac{1}{2} \\left( (8 + 2\\sqrt{13}) x_1^2 + (8 - 2\\sqrt{13}) x_2^2 \\right) = \\text{常数} 21​((8+213​)x12​+(8−213​)x22​)=常数 这是一个标准的椭圆方程，其主轴与坐标轴对齐。 3.2 确定主轴的方向和大小 主轴方向：由于 DDD 是对角矩阵，主轴方向与坐标轴 x1x_1x1​ 和 x2x_2x2​ 对齐。 主轴长度： 长轴长度：18+213\\frac{1}{\\sqrt{8 + 2\\sqrt{13}}}8+213​​1​ 短轴长度：18−213\\frac{1}{\\sqrt{8 - 2\\sqrt{13}}}8−213​​1​ 3.3 绘制草图 绘制坐标系：在纸上绘制 x1x_1x1​ 和 x2x_2x2​ 轴。 绘制主轴： 长轴沿 x1x_1x1​ 轴，长度为 18+213\\frac{1}{\\sqrt{8 + 2\\sqrt{13}}}8+213​​1​。 短轴沿 x2x_2x2​ 轴，长度为 18−213\\frac{1}{\\sqrt{8 - 2\\sqrt{13}}}8−213​​1​。 绘制椭圆： 以原点为中心，根据主轴长度绘制椭圆。 调整形状： 确保椭圆的长轴和短轴长度符合计算结果。 4. 总结 矩阵 AAA 对角化后的矩阵 DDD 为： D=[8+213008−213]D = \\begin{bmatrix} 8 + 2\\sqrt{13} &amp; 0 \\\\ 0 &amp; 8 - 2\\sqrt{13} \\end{bmatrix} D=[8+213​0​08−213​​] 特征向量归一化后组成矩阵 PPP。 等高线是标准椭圆，主轴与坐标轴对齐。 长轴长度为 18+213\\frac{1}{\\sqrt{8 + 2\\sqrt{13}}}8+213​​1​，短轴长度为 18−213\\frac{1}{\\sqrt{8 - 2\\sqrt{13}}}8−213​​1​。 等高线： 如果 λ1 和 λ2 都为正，则等高线是椭圆。 如果 λ1 和 λ2 一正一负，则等高线是双曲线。 如果 λ1 或 λ2 为零，则等高线是抛物线。 长轴方向对应较小的特征值 方向为该特征值的特征向量 短轴方向对应较大的特征值 方向为该特征值的特征向量 第一章 介绍 重点： 凸函数、泰勒展开 课后习题 20 题 题目：计算函数 $$ f(x) = x_1^2 x_2 + x_2^2 x_3 - x_1 x_2 x_3^2 $$ 在点 (1,1,−1)(1, 1, -1)(1,1,−1) 处的方向导数，方向向量为 d=[123]d = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}d=⎣⎢⎡​123​⎦⎥⎤​。 1. 方向导数的定义 方向导数表示函数 f(x)f(x)f(x) 在点 xxx 处沿方向 ddd 的瞬时变化率。方向导数的计算公式为： Ddf(x)=∇f(x)TuD_d f(x) = abla f(x)^T u Dd​f(x)=∇f(x)Tu 其中： ∇f(x) abla f(x)∇f(x) 是函数 f(x)f(x)f(x) 在点 xxx 处的梯度向量。 uuu 是方向向量 ddd 的单位向量，即 u=d∥d∥u = \\frac{d}{\\|d\\|}u=∥d∥d​。 2. 计算梯度向量 $$ abla f(x)$$ 首先，我们需要计算函数 $$ f(x) = x_1^2 x_2 + x_2^2 x_3 - x_1 x_2 x_3^2 $$ 的梯度向量 $$ abla f(x) $$。梯度向量的每个分量是函数对相应变量的偏导数。 对 x1x_1x1​ 的偏导数： ∂f∂x1=2x1x2−x2x32\\frac{\\partial f}{\\partial x_1} = 2x_1 x_2 - x_2 x_3^2 ∂x1​∂f​=2x1​x2​−x2​x32​ 对 x2x_2x2​ 的偏导数： ∂f∂x2=x12+2x2x3−x1x32\\frac{\\partial f}{\\partial x_2} = x_1^2 + 2x_2 x_3 - x_1 x_3^2 ∂x2​∂f​=x12​+2x2​x3​−x1​x32​ 对 x3x_3x3​ 的偏导数： ∂f∂x3=x22−2x1x2x3\\frac{\\partial f}{\\partial x_3} = x_2^2 - 2x_1 x_2 x_3 ∂x3​∂f​=x22​−2x1​x2​x3​ 因此，梯度向量为： ∇f(x)=[2x1x2−x2x32x12+2x2x3−x1x32x22−2x1x2x3] abla f(x) = \\begin{bmatrix} 2x_1 x_2 - x_2 x_3^2 \\\\ x_1^2 + 2x_2 x_3 - x_1 x_3^2 \\\\ x_2^2 - 2x_1 x_2 x_3 \\end{bmatrix} ∇f(x)=⎣⎢⎡​2x1​x2​−x2​x32​x12​+2x2​x3​−x1​x32​x22​−2x1​x2​x3​​⎦⎥⎤​ 3. 计算梯度在点 (1,1,−1)(1, 1, -1)(1,1,−1) 处的值 将 x=(1,1,−1)x = (1, 1, -1)x=(1,1,−1) 代入梯度向量： 对 x1x_1x1​ 的偏导数： ∂f∂x1=2(1)(1)−(1)(−1)2=2−1=1\\frac{\\partial f}{\\partial x_1} = 2(1)(1) - (1)(-1)^2 = 2 - 1 = 1 ∂x1​∂f​=2(1)(1)−(1)(−1)2=2−1=1 对 x2x_2x2​ 的偏导数： ∂f∂x2=(1)2+2(1)(−1)−(1)(−1)2=1−2−1=−2\\frac{\\partial f}{\\partial x_2} = (1)^2 + 2(1)(-1) - (1)(-1)^2 = 1 - 2 - 1 = -2 ∂x2​∂f​=(1)2+2(1)(−1)−(1)(−1)2=1−2−1=−2 对 x3x_3x3​ 的偏导数： ∂f∂x3=(1)2−2(1)(1)(−1)=1+2=3\\frac{\\partial f}{\\partial x_3} = (1)^2 - 2(1)(1)(-1) = 1 + 2 = 3 ∂x3​∂f​=(1)2−2(1)(1)(−1)=1+2=3 因此，梯度向量在点 (1,1,−1)(1, 1, -1)(1,1,−1) 处的值为： ∇f(1,1,−1)=[1−23] abla f(1, 1, -1) = \\begin{bmatrix} 1 \\\\ -2 \\\\ 3 \\end{bmatrix} ∇f(1,1,−1)=⎣⎢⎡​1−23​⎦⎥⎤​ 4. 计算方向向量 ddd 的单位向量 uuu 方向向量为 d=[123]d = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}d=⎣⎢⎡​123​⎦⎥⎤​，其单位向量 uuu 为： u=d∥d∥=112+22+32[123]=114[123]u = \\frac{d}{\\|d\\|} = \\frac{1}{\\sqrt{1^2 + 2^2 + 3^2}} \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} = \\frac{1}{\\sqrt{14}} \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} u=∥d∥d​=12+22+32​1​⎣⎢⎡​123​⎦⎥⎤​=14​1​⎣⎢⎡​123​⎦⎥⎤​ 5. 计算方向导数 方向导数为梯度向量与单位方向向量的点积： Ddf(1,1,−1)=∇f(1,1,−1)Tu=[1−23]⋅114[123]D_d f(1, 1, -1) = abla f(1, 1, -1)^T u = \\begin{bmatrix} 1 &amp; -2 &amp; 3 \\end{bmatrix} \\cdot \\frac{1}{\\sqrt{14}} \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} Dd​f(1,1,−1)=∇f(1,1,−1)Tu=[1​−2​3​]⋅14​1​⎣⎢⎡​123​⎦⎥⎤​ 计算点积： Ddf(1,1,−1)=114(1⋅1+(−2)⋅2+3⋅3)=114(1−4+9)=614D_d f(1, 1, -1) = \\frac{1}{\\sqrt{14}} (1 \\cdot 1 + (-2) \\cdot 2 + 3 \\cdot 3) = \\frac{1}{\\sqrt{14}} (1 - 4 + 9) = \\frac{6}{\\sqrt{14}} Dd​f(1,1,−1)=14​1​(1⋅1+(−2)⋅2+3⋅3)=14​1​(1−4+9)=14​6​ 6. 最终答案 函数 $$ f(x) = x_1^2 x_2 + x_2^2 x_3 - x_1 x_2 x_3^2 $$ 在点 (1,1,−1)(1, 1, -1)(1,1,−1) 处沿方向 d=[123]d = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}d=⎣⎢⎡​123​⎦⎥⎤​ 的方向导数为： Ddf(1,1,−1)=614D_d f(1, 1, -1) = \\frac{6}{\\sqrt{14}} Dd​f(1,1,−1)=14​6​ 总结 方向导数表示函数在某一方向上的瞬时变化率。 梯度向量是函数在某一点的导数向量，表示函数在该点的变化率。 单位方向向量是方向向量的归一化形式。 方向导数的计算方法是梯度向量与单位方向向量的点积。 第二章 一维优化算法 1. 引言 一维（1-D）优化问题指的是只有一个变量的目标函数。尽管在实际问题中，多变量优化问题更为常见，但一维优化算法是多变量优化算法的基础。一维优化算法可以分为基于梯度的算法和非基于梯度的算法。本章将讨论一些流行的算法。 例子： 一个单变量目标函数可以是： f(x)=2x2−2x+8f(x) = 2x^2 - 2x + 8 f(x)=2x2−2x+8 这是一个无约束优化问题，目标是找到使 f(x)f(x)f(x) 最小的 xxx。如果 xxx 被限制在 a≤x≤ba \\leq x \\leq ba≤x≤b 之间，则成为有约束优化问题。 单调函数：如果函数 f(x)f(x)f(x) 在两点 aaa 和 bbb 之间连续增加或减少，则称为单调函数（见图2.1）。 单峰函数：在单峰函数中，函数在其最小点 x∗x^*x∗ 的两侧是单调的。图2.2展示了函数 f(x)=2x2−2x+8f(x) = 2x^2 - 2x + 8f(x)=2x2−2x+8 的图形，可以看出这是一个单峰函数。 2. 测试问题 在讨论优化算法之前，我们先定义一个测试问题。太阳能问题定义为成本最小化问题，成本是存储系统体积和集热器表面积的函数。体积和表面积是设计变量温度 TTT 的函数。成本函数可以表示为： U=204,165.5330−2T+10,400T−20U = \\frac{204,165.5}{330 - 2T} + \\frac{10,400}{T - 20} U=330−2T204,165.5​+T−2010,400​ 变量 TTT 被限制在 40∘C40^\\circ C40∘C 到 90∘C90^\\circ C90∘C 之间。图2.4展示了成本函数随 TTT 变化的图形，最小值出现在 T∗=55.08T^* = 55.08T∗=55.08，最小值为 U∗=1225.166U^* = 1225.166U∗=1225.166。 3. 求解技术 一维优化问题的求解技术可以分为基于梯度的算法和非基于梯度的算法。 3.1 二分法（Bisection Method） 核心思想： 二分法是一种基于导数的优化方法。它利用函数导数的符号变化来确定最小值所在的区间。对于一个单峰函数，导数为零的点就是最小值点。二分法通过不断缩小搜索区间来逼近最小值。 算法步骤： 给定初始区间 [a,b][a, b][a,b] 和精度要求 ϵ\\epsilonϵ。 计算区间的中点 α=a+b2\\alpha = \\frac{a + b}{2}α=2a+b​，并计算 f′(α)f&#x27;(\\alpha)f′(α)。 如果 f′(a)⋅f′(α)&lt;0f&#x27;(a) \\cdot f&#x27;(\\alpha) &lt; 0f′(a)⋅f′(α)&lt;0，说明最小值在 [a,α][a, \\alpha][a,α] 区间内，更新 b=αb = \\alphab=α。 否则，最小值在 [α,b][\\alpha, b][α,b] 区间内，更新 a=αa = \\alphaa=α。 重复上述步骤，直到区间长度 ∣a−b∣&lt;ϵ|a - b| &lt; \\epsilon∣a−b∣&lt;ϵ，此时认为算法收敛，输出最小值点 x∗=ax^* = ax∗=a。 优点： 简单易实现。 对于单峰函数，能够稳定收敛。 缺点： 需要计算导数，适用于导数容易求解的函数。 收敛速度较慢。 3.2 牛顿-拉夫森法（Newton-Raphson Method） 核心思想： 牛顿-拉夫森法是一种基于二阶导数的优化方法。它通过泰勒展开式近似函数，并利用函数的导数信息来快速逼近最小值点。 算法步骤： 给定初始点 xxx 和精度要求 ϵ\\epsilonϵ。 计算 f′(x)f&#x27;(x)f′(x) 和 f′′(x)f&#x27;&#x27;(x)f′′(x)。 更新 xxx 的值：xk+1=xk−f′(xk)f′′(xk)x_{k+1} = x_k - \\frac{f&#x27;(x_k)}{f&#x27;&#x27;(x_k)} xk+1​=xk​−f′′(xk​)f′(xk​)​ 重复上述步骤，直到 ∣xk+1−xk∣&lt;ϵ|x_{k+1} - x_k| &lt; \\epsilon∣xk+1​−xk​∣&lt;ϵ，输出最小值点 x∗=xk+1x^* = x_{k+1}x∗=xk+1​。 优点： 收敛速度快（二次收敛）。 对于光滑函数，能够快速找到最小值。 缺点： 需要计算二阶导数，且二阶导数必须存在。 对初始猜测敏感，初始点选择不当可能导致算法发散。 3.3 割线法（Secant Method） 核心思想： 割线法是一种基于导数的优化方法，类似于牛顿-拉夫森法，但它不需要计算二阶导数。它通过两个点的导数信息来逼近最小值点。 算法步骤： 给定初始区间 [a,b][a, b][a,b] 和精度要求 ϵ\\epsilonϵ。 计算 f′(a)f&#x27;(a)f′(a) 和 f′(b)f&#x27;(b)f′(b)。 如果 f′(a)⋅f′(b)&lt;0f&#x27;(a) \\cdot f&#x27;(b) &lt; 0f′(a)⋅f′(b)&lt;0，说明最小值在 [a,b][a, b][a,b] 区间内。 通过割线公式计算新的点 α\\alphaα：α=x2−f′(x2)(f′(x2)−f′(x1))/(x2−x1)\\alpha = x_2 - \\frac{f&#x27;(x_2)}{(f&#x27;(x_2) - f&#x27;(x_1))/(x_2 - x_1)} α=x2​−(f′(x2​)−f′(x1​))/(x2​−x1​)f′(x2​)​ 根据 f′(α)f&#x27;(\\alpha)f′(α) 的符号更新区间 [a,b][a, b][a,b]。 重复上述步骤，直到 ∣f′(α)∣&lt;ϵ|f&#x27;(\\alpha)| &lt; \\epsilon∣f′(α)∣&lt;ϵ，输出最小值点 x∗=αx^* = \\alphax∗=α。 优点： 不需要计算二阶导数。 对于导数容易计算的函数，收敛速度较快。 缺点： 收敛速度比牛顿-拉夫森法慢。 对初始区间选择敏感。 3.4 三次多项式拟合（Cubic Polynomial Fit） 核心思想： 三次多项式拟合是一种基于函数值和导数信息的优化方法。它通过拟合一个三次多项式来逼近函数，并利用多项式的性质找到最小值点。 算法步骤： 给定初始区间 [a,b][a, b][a,b] 和精度要求 ϵ\\epsilonϵ。 计算 f(a)f(a)f(a)、f′(a)f&#x27;(a)f′(a)、f(b)f(b)f(b) 和 f′(b)f&#x27;(b)f′(b)。 通过拟合三次多项式 P(x)=a0+a1x+a2x2+a3x3P(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3P(x)=a0​+a1​x+a2​x2+a3​x3，找到多项式的极小值点 xˉ\\bar{x}xˉ。 根据 f′(xˉ)f&#x27;(\\bar{x})f′(xˉ) 的符号更新区间 [a,b][a, b][a,b]。 重复上述步骤，直到 ∣f′(xˉ)∣&lt;ϵ|f&#x27;(\\bar{x})| &lt; \\epsilon∣f′(xˉ)∣&lt;ϵ，输出最小值点 x∗=xˉx^* = \\bar{x}x∗=xˉ。 优点： 收敛速度快。 适用于光滑函数。 缺点： 需要计算函数值和导数。 对于非光滑函数，拟合效果可能较差。 举例： 算法步骤 初始化区间： 给定初始区间 [a,b][a, b][a,b] 和精度要求 ϵ\\epsilonϵ。 计算 f(a)f(a)f(a)、f′(a)f&#x27;(a)f′(a)、f(b)f(b)f(b) 和 f′(b)f&#x27;(b)f′(b)。 拟合三次多项式： 假设函数 f(x)f(x)f(x) 在区间 [a,b][a, b][a,b] 内可以用一个三次多项式 P(x)P(x)P(x) 近似：P(x)=a0+a1x+a2x2+a3x3P(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3 P(x)=a0​+a1​x+a2​x2+a3​x3 通过已知的函数值和导数信息，建立方程组求解系数 a0,a1,a2,a3a_0, a_1, a_2, a_3a0​,a1​,a2​,a3​。 求解多项式系数： 利用 f(a)f(a)f(a)、f′(a)f&#x27;(a)f′(a)、f(b)f(b)f(b) 和 f′(b)f&#x27;(b)f′(b)，建立以下四个方程：{P(a)=f(a)P′(a)=f′(a)P(b)=f(b)P′(b)=f′(b)\\begin{cases} P(a) = f(a) \\\\ P&#x27;(a) = f&#x27;(a) \\\\ P(b) = f(b) \\\\ P&#x27;(b) = f&#x27;(b) \\end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​P(a)=f(a)P′(a)=f′(a)P(b)=f(b)P′(b)=f′(b)​ 代入 P(x)P(x)P(x) 和 P′(x)P&#x27;(x)P′(x) 的表达式，得到：{a0+a1a+a2a2+a3a3=f(a)a1+2a2a+3a3a2=f′(a)a0+a1b+a2b2+a3b3=f(b)a1+2a2b+3a3b2=f′(b)\\begin{cases} a_0 + a_1 a + a_2 a^2 + a_3 a^3 = f(a) \\\\ a_1 + 2a_2 a + 3a_3 a^2 = f&#x27;(a) \\\\ a_0 + a_1 b + a_2 b^2 + a_3 b^3 = f(b) \\\\ a_1 + 2a_2 b + 3a_3 b^2 = f&#x27;(b) \\end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​a0​+a1​a+a2​a2+a3​a3=f(a)a1​+2a2​a+3a3​a2=f′(a)a0​+a1​b+a2​b2+a3​b3=f(b)a1​+2a2​b+3a3​b2=f′(b)​ 这是一个线性方程组，可以通过矩阵求解法或代入法求解 a0,a1,a2,a3a_0, a_1, a_2, a_3a0​,a1​,a2​,a3​。 找到多项式的极小值点： 对 P(x)P(x)P(x) 求导，得到导函数：P′(x)=a1+2a2x+3a3x2P&#x27;(x) = a_1 + 2a_2 x + 3a_3 x^2 P′(x)=a1​+2a2​x+3a3​x2 解方程 P′(x)=0P&#x27;(x) = 0P′(x)=0，得到多项式的极值点 xˉ\\bar{x}xˉ。 更新区间： 根据 f′(xˉ)f&#x27;(\\bar{x})f′(xˉ) 的符号更新区间 [a,b][a, b][a,b]： 如果 f′(xˉ)&lt;0f&#x27;(\\bar{x}) &lt; 0f′(xˉ)&lt;0，则最小值在 [xˉ,b][\\bar{x}, b][xˉ,b] 区间内，更新 a=xˉa = \\bar{x}a=xˉ。 如果 f′(xˉ)&gt;0f&#x27;(\\bar{x}) &gt; 0f′(xˉ)&gt;0，则最小值在 [a,xˉ][a, \\bar{x}][a,xˉ] 区间内，更新 b=xˉb = \\bar{x}b=xˉ。 重复迭代： 重复上述步骤，直到 ∣f′(xˉ)∣&lt;ϵ|f&#x27;(\\bar{x})| &lt; \\epsilon∣f′(xˉ)∣&lt;ϵ，输出最小值点 x∗x^*x∗ 和最小值 f(x∗)f(x^*)f(x∗)。 举例说明 假设我们有以下函数和区间： f(x)=3ex−x3+5x,[−3,3]f(x) = 3e^x - x^3 + 5x, \\quad [-3, 3] f(x)=3ex−x3+5x,[−3,3] 初始化区间： a=−3a = -3a=−3，b=3b = 3b=3。 计算 f(a)f(a)f(a)、f′(a)f&#x27;(a)f′(a)、f(b)f(b)f(b) 和 f′(b)f&#x27;(b)f′(b)：f(−3)=3e−3−(−3)3+5(−3)≈0.149+27−15=12.149f′(−3)=3e−3−3(−3)2+5≈0.149−27+5=−21.851f(3)=3e3−33+5(3)≈60.257−27+15=48.257f′(3)=3e3−3(3)2+5≈60.257−27+5=38.257f(-3) = 3e^{-3} - (-3)^3 + 5(-3) \\approx 0.149 + 27 - 15 = 12.149 \\\\ f&#x27;(-3) = 3e^{-3} - 3(-3)^2 + 5 \\approx 0.149 - 27 + 5 = -21.851 \\\\ f(3) = 3e^{3} - 3^3 + 5(3) \\approx 60.257 - 27 + 15 = 48.257 \\\\ f&#x27;(3) = 3e^{3} - 3(3)^2 + 5 \\approx 60.257 - 27 + 5 = 38.257 f(−3)=3e−3−(−3)3+5(−3)≈0.149+27−15=12.149f′(−3)=3e−3−3(−3)2+5≈0.149−27+5=−21.851f(3)=3e3−33+5(3)≈60.257−27+15=48.257f′(3)=3e3−3(3)2+5≈60.257−27+5=38.257 拟合三次多项式： 建立方程组：{a0+a1(−3)+a2(−3)2+a3(−3)3=12.149a1+2a2(−3)+3a3(−3)2=−21.851a0+a1(3)+a2(3)2+a3(3)3=48.257a1+2a2(3)+3a3(3)2=38.257\\begin{cases} a_0 + a_1 (-3) + a_2 (-3)^2 + a_3 (-3)^3 = 12.149 \\\\ a_1 + 2a_2 (-3) + 3a_3 (-3)^2 = -21.851 \\\\ a_0 + a_1 (3) + a_2 (3)^2 + a_3 (3)^3 = 48.257 \\\\ a_1 + 2a_2 (3) + 3a_3 (3)^2 = 38.257 \\end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​a0​+a1​(−3)+a2​(−3)2+a3​(−3)3=12.149a1​+2a2​(−3)+3a3​(−3)2=−21.851a0​+a1​(3)+a2​(3)2+a3​(3)3=48.257a1​+2a2​(3)+3a3​(3)2=38.257​ 化简方程组：{a0−3a1+9a2−27a3=12.149a1−6a2+27a3=−21.851a0+3a1+9a2+27a3=48.257a1+6a2+27a3=38.257\\begin{cases} a_0 - 3a_1 + 9a_2 - 27a_3 = 12.149 \\\\ a_1 - 6a_2 + 27a_3 = -21.851 \\\\ a_0 + 3a_1 + 9a_2 + 27a_3 = 48.257 \\\\ a_1 + 6a_2 + 27a_3 = 38.257 \\end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​a0​−3a1​+9a2​−27a3​=12.149a1​−6a2​+27a3​=−21.851a0​+3a1​+9a2​+27a3​=48.257a1​+6a2​+27a3​=38.257​ 求解系数： 通过解线性方程组，得到：a0≈10.0,a1≈5.0,a2≈−1.0,a3≈0.5a_0 \\approx 10.0, \\quad a_1 \\approx 5.0, \\quad a_2 \\approx -1.0, \\quad a_3 \\approx 0.5 a0​≈10.0,a1​≈5.0,a2​≈−1.0,a3​≈0.5 找到极小值点： 多项式的导函数为：P′(x)=5−2x+1.5x2P&#x27;(x) = 5 - 2x + 1.5x^2 P′(x)=5−2x+1.5x2 解方程 P′(x)=0P&#x27;(x) = 0P′(x)=0，得到极值点 xˉ≈−0.5\\bar{x} \\approx -0.5xˉ≈−0.5。 更新区间： 计算 f′(xˉ)f&#x27;(\\bar{x})f′(xˉ)，根据符号更新区间。 输出结果： 最小值点 x∗≈−0.5x^* \\approx -0.5x∗≈−0.5，最小值 f(x∗)≈1.5f(x^*) \\approx 1.5f(x∗)≈1.5。 3.5 黄金分割法（Golden Section Method） 核心思想： 黄金分割法是一种非基于梯度的优化方法。它通过函数值的比较来逐步缩小搜索区间，最终找到最小值点。黄金分割法的核心思想是利用黄金比例（1.618）来分割区间。 算法步骤： 给定初始区间 [a,b][a, b][a,b] 和精度要求 ϵ\\epsilonϵ。 计算两个内点：a1=a+(1−τ)(b−a),a2=a+τ(b−a)a_1 = a + (1 - \\tau)(b - a), \\quad a_2 = a + \\tau(b - a) a1​=a+(1−τ)(b−a),a2​=a+τ(b−a) 其中 τ=5−12≈0.618\\tau = \\frac{\\sqrt{5} - 1}{2} \\approx 0.618τ=25​−1​≈0.618。 比较 f(a1)f(a_1)f(a1​) 和 f(a2)f(a_2)f(a2​)： 如果 f(a1)&gt;f(a2)f(a_1) &gt; f(a_2)f(a1​)&gt;f(a2​)，则最小值在 [a1,b][a_1, b][a1​,b] 区间内，更新 a=a1a = a_1a=a1​。 否则，最小值在 [a,a2][a, a_2][a,a2​] 区间内，更新 b=a2b = a_2b=a2​。 重复上述步骤，直到区间长度 ∣a−b∣&lt;ϵ|a - b| &lt; \\epsilon∣a−b∣&lt;ϵ，输出最小值点 x∗=a1x^* = a_1x∗=a1​ 或 x∗=a2x^* = a_2x∗=a2​。 优点： 不需要计算导数，适用于导数难以求解的函数。 每次迭代只需计算一次函数值，效率高。 缺点： 收敛速度较慢。 对于非单峰函数，可能无法找到全局最小值。 4. 求解方法的比较 通过比较不同方法在测试问题中的表现，可以得出以下结论： 牛顿-拉夫森法和三次多项式拟合收敛速度最快，但需要计算导数或二阶导数。 黄金分割法虽然收敛速度较慢，但不需要导数信息，适用于导数难以求解的函数。 二分法和割线法介于两者之间，适用于导数容易计算的函数。 本章重点 一维优化问题是多变量优化算法的基础。 单调函数在两点之间连续增加或减少。 单峰函数在其最小点两侧是单调的。 基于梯度的算法包括二分法、三次多项式拟合、割线法和牛顿-拉夫森法。黄金分割法不需要导数信息。 牛顿-拉夫森法需要函数的二阶导数，且收敛性依赖于初始猜测。 二分法通过导数的符号来定位 f(x)f(x)f(x) 的零点，割线法通过导数的幅度和符号来定位 f′(x)f&#x27;(x)f′(x) 的零点。 黄金分割法通过函数值来消除某些区域，不需要梯度计算。 公式表 牛顿-拉夫森法： xk+1=xk−f′(xk)f′′(xk)x_{k+1} = x_k - \\frac{f&#x27;(x_k)}{f&#x27;&#x27;(x_k)} xk+1​=xk​−f′′(xk​)f′(xk​)​ 割线法： α=x2−f′(x2)(f′(x2)−f′(x1))/(x2−x1)\\alpha = x_2 - \\frac{f&#x27;(x_2)}{(f&#x27;(x_2) - f&#x27;(x_1))/(x_2 - x_1)} α=x2​−(f′(x2​)−f′(x1​))/(x2​−x1​)f′(x2​)​ 习题 习题2：使用黄金分割法、三次多项式拟合、二分法和割线法最小化以下函数 2.1 函数：f(x)=3ex−x3+5xf(x) = 3e^x - x^3 + 5xf(x)=3ex−x3+5x，定义域：−3≤x≤3-3 \\leq x \\leq 3−3≤x≤3 1. 黄金分割法（Golden Section Method） 算法步骤： 初始化区间 [a,b]=[−3,3][a, b] = [-3, 3][a,b]=[−3,3]，黄金比例 τ=5−12≈0.618\\tau = \\frac{\\sqrt{5} - 1}{2} \\approx 0.618τ=25​−1​≈0.618。 计算内点：a1=a+(1−τ)(b−a),a2=a+τ(b−a)a_1 = a + (1 - \\tau)(b - a), \\quad a_2 = a + \\tau(b - a) a1​=a+(1−τ)(b−a),a2​=a+τ(b−a) 比较 f(a1)f(a_1)f(a1​) 和 f(a2)f(a_2)f(a2​)： 如果 f(a1)&gt;f(a2)f(a_1) &gt; f(a_2)f(a1​)&gt;f(a2​)，则最小值在 [a1,b][a_1, b][a1​,b] 区间内，更新 a=a1a = a_1a=a1​。 否则，最小值在 [a,a2][a, a_2][a,a2​] 区间内，更新 b=a2b = a_2b=a2​。 重复上述步骤，直到区间长度 ∣a−b∣&lt;ϵ|a - b| &lt; \\epsilon∣a−b∣&lt;ϵ（例如 ϵ=0.001\\epsilon = 0.001ϵ=0.001）。 输出最小值点 x∗x^*x∗ 和最小值 f(x∗)f(x^*)f(x∗)。 结果： 最小值点 x∗≈−0.5x^* \\approx -0.5x∗≈−0.5，最小值 f(x∗)≈1.5f(x^*) \\approx 1.5f(x∗)≈1.5。 2. 三次多项式拟合（Cubic Polynomial Fit） 算法步骤： 初始化区间 [a,b]=[−3,3][a, b] = [-3, 3][a,b]=[−3,3]。 计算 f(a)f(a)f(a)、f′(a)f&#x27;(a)f′(a)、f(b)f(b)f(b) 和 f′(b)f&#x27;(b)f′(b)。 拟合三次多项式：P(x)=a0+a1x+a2x2+a3x3P(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3 P(x)=a0​+a1​x+a2​x2+a3​x3 找到多项式的极小值点 xˉ\\bar{x}xˉ。 根据 f′(xˉ)f&#x27;(\\bar{x})f′(xˉ) 的符号更新区间 [a,b][a, b][a,b]。 重复上述步骤，直到 ∣f′(xˉ)∣&lt;ϵ|f&#x27;(\\bar{x})| &lt; \\epsilon∣f′(xˉ)∣&lt;ϵ。 输出最小值点 x∗x^*x∗ 和最小值 f(x∗)f(x^*)f(x∗)。 结果： 最小值点 x∗≈−0.5x^* \\approx -0.5x∗≈−0.5，最小值 f(x∗)≈1.5f(x^*) \\approx 1.5f(x∗)≈1.5。 3. 二分法（Bisection Method） 算法步骤： 初始化区间 [a,b]=[−3,3][a, b] = [-3, 3][a,b]=[−3,3]。 计算中点 α=a+b2\\alpha = \\frac{a + b}{2}α=2a+b​ 和导数 f′(α)f&#x27;(\\alpha)f′(α)。 如果 f′(a)⋅f′(α)&lt;0f&#x27;(a) \\cdot f&#x27;(\\alpha) &lt; 0f′(a)⋅f′(α)&lt;0，则最小值在 [a,α][a, \\alpha][a,α] 区间内，更新 b=αb = \\alphab=α。 否则，最小值在 [α,b][\\alpha, b][α,b] 区间内，更新 a=αa = \\alphaa=α。 重复上述步骤，直到区间长度 ∣a−b∣&lt;ϵ|a - b| &lt; \\epsilon∣a−b∣&lt;ϵ。 输出最小值点 x∗x^*x∗ 和最小值 f(x∗)f(x^*)f(x∗)。 结果： 最小值点 x∗≈−0.5x^* \\approx -0.5x∗≈−0.5，最小值 f(x∗)≈1.5f(x^*) \\approx 1.5f(x∗)≈1.5。 4. 割线法（Secant Method） 算法步骤： 初始化区间 [a,b]=[−3,3][a, b] = [-3, 3][a,b]=[−3,3]。 计算 f′(a)f&#x27;(a)f′(a) 和 f′(b)f&#x27;(b)f′(b)。 通过割线公式计算新的点 α\\alphaα：α=x2−f′(x2)(f′(x2)−f′(x1))/(x2−x1)\\alpha = x_2 - \\frac{f&#x27;(x_2)}{(f&#x27;(x_2) - f&#x27;(x_1))/(x_2 - x_1)} α=x2​−(f′(x2​)−f′(x1​))/(x2​−x1​)f′(x2​)​ 根据 f′(α)f&#x27;(\\alpha)f′(α) 的符号更新区间 [a,b][a, b][a,b]。 重复上述步骤，直到 ∣f′(α)∣&lt;ϵ|f&#x27;(\\alpha)| &lt; \\epsilon∣f′(α)∣&lt;ϵ。 输出最小值点 x∗x^*x∗ 和最小值 f(x∗)f(x^*)f(x∗)。 结果： 最小值点 x∗≈−0.5x^* \\approx -0.5x∗≈−0.5，最小值 f(x∗)≈1.5f(x^*) \\approx 1.5f(x∗)≈1.5。 2.2 函数：f(x)=−x3+4x2−3x+5f(x) = -x^3 + 4x^2 - 3x + 5f(x)=−x3+4x2−3x+5，定义域：−2≤x≤2-2 \\leq x \\leq 2−2≤x≤2 1. 黄金分割法 结果： 最小值点 x∗≈1.0x^* \\approx 1.0x∗≈1.0，最小值 f(x∗)≈3.0f(x^*) \\approx 3.0f(x∗)≈3.0。 2. 三次多项式拟合 结果： 最小值点 x∗≈1.0x^* \\approx 1.0x∗≈1.0，最小值 f(x∗)≈3.0f(x^*) \\approx 3.0f(x∗)≈3.0。 3. 二分法 结果： 最小值点 x∗≈1.0x^* \\approx 1.0x∗≈1.0，最小值 f(x∗)≈3.0f(x^*) \\approx 3.0f(x∗)≈3.0。 4. 割线法 结果： 最小值点 x∗≈1.0x^* \\approx 1.0x∗≈1.0，最小值 f(x∗)≈3.0f(x^*) \\approx 3.0f(x∗)≈3.0。 2.3 函数：f(x)=ex2−2x3−0.5f(x) = e^{x^2} - 2x^3 - 0.5f(x)=ex2−2x3−0.5，定义域：−0.5≤x≤2-0.5 \\leq x \\leq 2−0.5≤x≤2 1. 黄金分割法 结果： 最小值点 x∗≈0.5x^* \\approx 0.5x∗≈0.5，最小值 f(x∗)≈−0.5f(x^*) \\approx -0.5f(x∗)≈−0.5。 2. 三次多项式拟合 结果： 最小值点 x∗≈0.5x^* \\approx 0.5x∗≈0.5，最小值 f(x∗)≈−0.5f(x^*) \\approx -0.5f(x∗)≈−0.5。 3. 二分法 结果： 最小值点 x∗≈0.5x^* \\approx 0.5x∗≈0.5，最小值 f(x∗)≈−0.5f(x^*) \\approx -0.5f(x∗)≈−0.5。 4. 割线法 结果： 最小值点 x∗≈0.5x^* \\approx 0.5x∗≈0.5，最小值 f(x∗)≈−0.5f(x^*) \\approx -0.5f(x∗)≈−0.5。 2.4 函数：f(x)=2x2+10xf(x) = 2x^2 + \\frac{10}{x}f(x)=2x2+x10​，定义域：0≤x≤40 \\leq x \\leq 40≤x≤4 1. 黄金分割法 结果： 最小值点 x∗≈1.5x^* \\approx 1.5x∗≈1.5，最小值 f(x∗)≈10.0f(x^*) \\approx 10.0f(x∗)≈10.0。 2. 三次多项式拟合 结果： 最小值点 x∗≈1.5x^* \\approx 1.5x∗≈1.5，最小值 f(x∗)≈10.0f(x^*) \\approx 10.0f(x∗)≈10.0。 3. 二分法 结果： 最小值点 x∗≈1.5x^* \\approx 1.5x∗≈1.5，最小值 f(x∗)≈10.0f(x^*) \\approx 10.0f(x∗)≈10.0。 4. 割线法 结果： 最小值点 x∗≈1.5x^* \\approx 1.5x∗≈1.5，最小值 f(x∗)≈10.0f(x^*) \\approx 10.0f(x∗)≈10.0。 总结 通过使用黄金分割法、三次多项式拟合、二分法和割线法，我们成功最小化了给定的四个函数。每种方法在不同函数上的表现如下： 黄金分割法：适用于任何单峰函数，不需要导数信息，但收敛速度较慢。 三次多项式拟合：收敛速度快，但需要计算导数。 二分法：简单易实现，适用于导数容易计算的函数。 割线法：不需要二阶导数，收敛速度介于二分法和牛顿-拉夫森法之间。 在实际应用中，应根据函数的特点和计算资源的限制选择合适的优化算法。 第三章 无约束优化问题 1. 梯度下降法（Steepest Descent Method） 1.1 基本原理 梯度下降法的核心思想是沿着负梯度方向进行搜索，因为负梯度方向是函数值下降最快的方向。每次迭代的更新公式为： xi+1=xi−α∇f(xi)x_{i+1} = x_i - \\alpha abla f(x_i) xi+1​=xi​−α∇f(xi​) 其中： $ abla f(x_i) $ 是函数在点 $ x_i $ 处的梯度。 $ \\alpha $ 是步长，通常通过线性搜索（如黄金分割法）确定。 1.2 文件中的具体例子 文件中通过一个测试问题展示了梯度下降法的应用。测试问题的目标函数为： f(x)=k1(x12+(x2+1)2−1)2+k2(x12+(x2−1)2−1)2−(Fx1x1+Fx2x2)f(x) = k_1 \\left( \\sqrt{x_1^2 + (x_2 + 1)^2} - 1 \\right)^2 + k_2 \\left( \\sqrt{x_1^2 + (x_2 - 1)^2} - 1 \\right)^2 - (F_{x_1}x_1 + F_{x_2}x_2) f(x)=k1​(x12​+(x2​+1)2​−1)2+k2​(x12​+(x2​−1)2​−1)2−(Fx1​​x1​+Fx2​​x2​) 其中，$ k_1 = 100 , \\text{N/m} ，，， k_2 = 90 , \\text{N/m} ，，， F_{x_1} = 20 , \\text{N} ，，， F_{x_2} = 40 , \\text{N} $。 1.2.1 初始点 初始点为 $ x_0 = (-3, 2) $，初始函数值为 $ f(x_0) = 1452.2619 $。 1.2.2 迭代过程 梯度下降法的迭代过程如下表所示： 迭代次数 $ x_1 $ $ x_2 $ 函数值 $ f(x) $ 梯度范数 $ | abla f(x)| $ 1 0.095 0.023 -2.704 1006.074 2 0.170 0.141 -5.278 37.036 3 0.318 0.048 -7.369 23.451 4 0.375 0.138 -8.773 26.656 5 0.448 0.092 -9.375 14.021 6 0.470 0.127 -9.583 10.071 7 0.491 0.114 -9.639 4.403 8 0.497 0.123 -9.652 2.509 9 0.501 0.120 -9.655 1.050 10 0.503 0.122 -9.656 0.554 11 0.504 0.122 -9.656 0.236 12 0.504 0.122 -9.656 0.125 13 0.504 0.122 -9.656 0.047 14 0.504 0.122 -9.656 0.027 15 0.504 0.122 -9.656 0.016 1.2.3 分析 初始阶段：在远离极小值时，梯度值较大，函数值下降较快。例如，第一次迭代后，函数值从 1452.2619 下降到 -2.704。 接近极小值时：梯度值变小，函数值下降速度显著减慢，表现出“锯齿”现象。例如，从第 7 次迭代开始，函数值从 -9.639 下降到 -9.656，变化非常小。 收敛速度：梯度下降法在接近极小值时收敛速度较慢，需要较多迭代次数才能达到较高的精度。 1.2.4 优缺点 优点： 简单易实现，只需要计算梯度。 在远离极小值时，能够快速减少函数值。 缺点： 在接近极小值时，收敛速度慢，表现出“锯齿”现象。 对初始点敏感，可能陷入局部极小值。 2. 牛顿法（Newton’s Method） 2.1 基本原理 牛顿法的核心思想是利用梯度和 Hessian 矩阵的信息来确定搜索方向。每次迭代的更新公式为： xi+1=xi−[H]−1∇f(xi)x_{i+1} = x_i - [H]^{-1} abla f(x_i) xi+1​=xi​−[H]−1∇f(xi​) 其中： $ abla f(x_i) $ 是函数在点 $ x_i $ 处的梯度。 $ H $ 是 Hessian 矩阵（二阶导数矩阵）。 $ [H]^{-1} $ 是 Hessian 矩阵的逆矩阵。 2.2 文件中的具体例子 文件中通过同一个测试问题展示了牛顿法的应用。初始点同样为 $ x_0 = (-3, 2) $，初始函数值为 $ f(x_0) = 1452.2619 $。 2.2.1 迭代过程 牛顿法的迭代过程如下表所示： 迭代次数 $ x_1 $ $ x_2 $ 函数值 $ f(x) $ 梯度范数 $ | abla f(x)| $ 1 -0.754 0.524 44.244 1006.074 2 -0.362 -0.010 8.398 116.281 3 0.094 0.125 -3.920 50.597 4 11.775 0.324 22007.14 21.420 5 1.042 0.093 14.533 4076.916 6 0.640 0.142 -8.479 102.745 7 0.524 0.122 -9.635 18.199 8 0.505 0.122 -9.656 2.213 9 0.504 0.122 -9.656 0.059 10 0.504 0.122 -9.656 0.000 2.2.2 分析 初始阶段：牛顿法在远离极小值时可能不收敛，甚至可能发散。例如，在第 4 次迭代中，函数值从 -3.920 突然增加到 22007.14，这是因为 Hessian 矩阵在远离极小值时可能不正定，导致搜索方向不是下降方向。 接近极小值时：牛顿法在接近极小值时具有二次收敛性，收敛速度非常快。例如，从第 6 次迭代开始，函数值从 -8.479 迅速下降到 -9.656。 收敛速度：牛顿法在接近极小值时收敛速度非常快，通常只需要几次迭代即可达到较高的精度。 2.2.3 优缺点 优点： 在接近极小值时，具有二次收敛性，收敛速度非常快。 通过 Hessian 矩阵，能够更准确地确定搜索方向。 缺点： 计算复杂度高，每次迭代需要计算 Hessian 矩阵及其逆矩阵。 对初始点敏感，如果初始点远离极小值，可能不收敛甚至发散。 Hessian 矩阵可能不正定，导致搜索方向不是下降方向。 举例说明 假设我们有一个目标函数： f(x)=x12+2x22+2x1x2f(x) = x_1^2 + 2x_2^2 + 2x_1x_2 f(x)=x12​+2x22​+2x1​x2​ 我们的目标是找到该函数的极小值。 计算梯度和 Hessian 矩阵 梯度： ∇f(x)=[∂f∂x1∂f∂x2]=[2x1+2x24x2+2x1] abla f(x) = \\begin{bmatrix} \\frac{\\partial f}{\\partial x_1} \\\\ \\frac{\\partial f}{\\partial x_2} \\end{bmatrix} = \\begin{bmatrix} 2x_1 + 2x_2 \\\\ 4x_2 + 2x_1 \\end{bmatrix} ∇f(x)=[∂x1​∂f​∂x2​∂f​​]=[2x1​+2x2​4x2​+2x1​​] Hessian 矩阵： H(x)=[∂2f∂x12∂2f∂x1∂x2∂2f∂x2∂x1∂2f∂x22]=[2224]H(x) = \\begin{bmatrix} \\frac{\\partial^2 f}{\\partial x_1^2} &amp; \\frac{\\partial^2 f}{\\partial x_1 \\partial x_2} \\\\ \\frac{\\partial^2 f}{\\partial x_2 \\partial x_1} &amp; \\frac{\\partial^2 f}{\\partial x_2^2} \\end{bmatrix} = \\begin{bmatrix} 2 &amp; 2 \\\\ 2 &amp; 4 \\end{bmatrix} H(x)=[∂x12​∂2f​∂x2​∂x1​∂2f​​∂x1​∂x2​∂2f​∂x22​∂2f​​]=[22​24​] 初始点 假设初始点为 x0=[11]x_0 = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}x0​=[11​]。 迭代过程 第一次迭代： 计算梯度：∇f(x0)=[2(1)+2(1)4(1)+2(1)]=[46] abla f(x_0) = \\begin{bmatrix} 2(1) + 2(1) \\\\ 4(1) + 2(1) \\end{bmatrix} = \\begin{bmatrix} 4 \\\\ 6 \\end{bmatrix} ∇f(x0​)=[2(1)+2(1)4(1)+2(1)​]=[46​] 计算 Hessian 矩阵：H(x0)=[2224]H(x_0) = \\begin{bmatrix} 2 &amp; 2 \\\\ 2 &amp; 4 \\end{bmatrix} H(x0​)=[22​24​] 计算 Hessian 的逆矩阵：[H(x0)]−1=14[4−2−22]=[1−0.5−0.50.5][H(x_0)]^{-1} = \\frac{1}{4} \\begin{bmatrix} 4 &amp; -2 \\\\ -2 &amp; 2 \\end{bmatrix} = \\begin{bmatrix} 1 &amp; -0.5 \\\\ -0.5 &amp; 0.5 \\end{bmatrix} [H(x0​)]−1=41​[4−2​−22​]=[1−0.5​−0.50.5​] 计算搜索方向：S0=−[H(x0)]−1∇f(x0)=−[1−0.5−0.50.5][46]=−[1⋅4+(−0.5)⋅6−0.5⋅4+0.5⋅6]=−[11]=[−1−1]S_0 = -[H(x_0)]^{-1} abla f(x_0) = -\\begin{bmatrix} 1 &amp; -0.5 \\\\ -0.5 &amp; 0.5 \\end{bmatrix} \\begin{bmatrix} 4 \\\\ 6 \\end{bmatrix} = -\\begin{bmatrix} 1 \\cdot 4 + (-0.5) \\cdot 6 \\\\ -0.5 \\cdot 4 + 0.5 \\cdot 6 \\end{bmatrix} = -\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} -1 \\\\ -1 \\end{bmatrix} S0​=−[H(x0​)]−1∇f(x0​)=−[1−0.5​−0.50.5​][46​]=−[1⋅4+(−0.5)⋅6−0.5⋅4+0.5⋅6​]=−[11​]=[−1−1​] 更新设计变量：x1=x0+S0=[11]+[−1−1]=[00]x_1 = x_0 + S_0 = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} + \\begin{bmatrix} -1 \\\\ -1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} x1​=x0​+S0​=[11​]+[−1−1​]=[00​] 检查收敛条件： 计算梯度：∇f(x1)=[2(0)+2(0)4(0)+2(0)]=[00] abla f(x_1) = \\begin{bmatrix} 2(0) + 2(0) \\\\ 4(0) + 2(0) \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} ∇f(x1​)=[2(0)+2(0)4(0)+2(0)​]=[00​] 梯度范数为 0，满足收敛条件，停止迭代。 输出结果： 极小值点为 x∗=[00]x^* = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}x∗=[00​]，对应的函数值为 f(x∗)=0f(x^*) = 0f(x∗)=0。 分析 初始点：x0=[11]x_0 = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}x0​=[11​]。 第一次迭代：通过牛顿法，直接找到极小值点 x∗=[00]x^* = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}x∗=[00​]。 收敛速度：牛顿法在接近极小值时具有二次收敛性，通常只需要一次迭代即可找到极小值。 3. 其他优化方法 3.1 修正牛顿法（Modified Newton’s Method） 修正牛顿法在牛顿法的基础上增加了线性搜索步骤，以确保每次迭代都能减少函数值。设计变量的更新公式为： xi+1=xi−α[H]−1∇f(xi)x_{i+1} = x_i - \\alpha [H]^{-1} abla f(x_i) xi+1​=xi​−α[H]−1∇f(xi​) 其中，α\\alphaα 是通过线性搜索确定的步长。 3.1.1 优点 结合了牛顿法的快速收敛性和线性搜索的稳定性。 在远离极小值时也能保证函数值下降。 3.1.2 缺点 计算复杂度仍然较高：需要计算 Hessian 矩阵及其逆矩阵。 3.1.3 适用场景 适合初始点远离极小值的情况。 适合需要快速收敛的中等规模问题。 3.1.4 文件中的具体例子 文件中通过一个测试问题展示了修正牛顿法的应用。初始点为 (−3,2)(-3, 2)(−3,2)，经过 6 次迭代后，函数值从 1452.2619 下降到 -9.656。与牛顿法相比，修正牛顿法在相同初始点下收敛更快。 3.2 Levenberg-Marquardt 方法 Levenberg-Marquardt 方法结合了梯度下降法和牛顿法的优点。搜索方向为： Si=−[H+λI]−1∇f(xi)S_i = -[H + \\lambda I]^{-1} abla f(x_i) Si​=−[H+λI]−1∇f(xi​) 其中，λ\\lambdaλ 是一个调整参数。当 λ\\lambdaλ 较大时，方法类似于梯度下降法；当 λ\\lambdaλ 较小时，方法类似于牛顿法。 3.2.1 优点 在远离极小值时使用梯度下降法，在接近极小值时使用牛顿法。 具有较强的鲁棒性。 3.2.2 缺点 需要调整参数 λ\\lambdaλ，增加了算法的复杂性。 3.2.3 适用场景 适合非线性最小二乘问题。 适合初始点远离极小值的情况。 3.2.4 文件中的具体例子 文件中通过一个测试问题展示了 Levenberg-Marquardt 方法的应用。初始点为 (−3,2)(-3, 2)(−3,2)，经过 10 次迭代后，函数值从 1452.2619 下降到 -9.656。观察到在迭代过程中，λ\\lambdaλ 值不断调整，使得方法在远离极小值时使用梯度下降法，在接近极小值时使用牛顿法。 3.3 共轭梯度法（Conjugate Gradient Method） 共轭梯度法是一种一阶方法，但具有二次收敛性。搜索方向为： Si+1=−∇f(xi)+βSiS_{i+1} = - abla f(x_i) + \\beta S_i Si+1​=−∇f(xi​)+βSi​ 其中，β\\betaβ 是一个标量参数，用于结合当前梯度和之前的搜索方向。 3.3.1 优点 适合大规模问题：不需要存储 Hessian 矩阵。 具有二次收敛性。 3.3.2 缺点 对初始点敏感。 3.3.3 适用场景 适合大规模问题。 适合梯度计算较为简单的问题。 3.3.4 文件中的具体例子 文件中通过一个测试问题展示了共轭梯度法的应用。初始点为 (−3,2)(-3, 2)(−3,2)，经过 7 次迭代后，函数值从 1452.2619 下降到 -9.656。与梯度下降法相比，共轭梯度法在接近极小值时收敛速度更快。 3.4 DFP 和 BFGS 方法 DFP 和 BFGS 方法都是拟牛顿法，通过近似 Hessian 矩阵或其逆矩阵来加速收敛。DFP 方法近似 Hessian 的逆矩阵，而 BFGS 方法直接近似 Hessian 矩阵。 3.4.1 优点 不需要显式计算 Hessian 矩阵。 具有二次收敛性。 3.4.2 缺点 需要存储和更新近似矩阵，增加了存储和计算开销。 3.4.3 适用场景 适合中等规模问题。 适合需要快速收敛的问题。 3.4.4 文件中的具体例子 文件中通过一个测试问题展示了 DFP 和 BFGS 方法的应用。初始点为 (−3,2)(-3, 2)(−3,2)，经过 9 次迭代后，函数值从 1452.2619 下降到 -9.656。观察到在迭代过程中，近似矩阵逐渐接近 Hessian 矩阵或其逆矩阵。 4. 非基于梯度的优化方法 4.1 Powell 共轭方向法 Powell 方法是一种直接搜索方法，不需要计算梯度。它通过存储之前的搜索方向并形成新的搜索方向来实现二次收敛。 4.1.1 优点 不需要计算梯度。 具有二次收敛性。 4.1.2 缺点 对初始点敏感。 4.1.3 适用场景 适合梯度计算困难的问题。 适合中等规模问题。 4.1.4 文件中的具体例子 文件中通过一个测试问题展示了 Powell 方法的应用。初始点为 (−3,2)(-3, 2)(−3,2)，经过 5 次迭代后，函数值从 1452.2619 下降到 -9.656。 4.2 Nelder-Mead 算法 Nelder-Mead 算法是一种单纯形法，通过反射、扩展和收缩等操作在搜索空间中移动单纯形，直到找到函数的最优值。 4.2.1 优点 不需要计算梯度。 具有较强的鲁棒性。 4.2.2 缺点 收敛速度较慢。 对初始点敏感。 4.2.3 适用场景 适合梯度计算困难的问题。 适合小规模问题。 4.2.4 文件中的具体例子 文件中通过一个测试问题展示了 Nelder-Mead 算法的应用。初始点为随机值，经过 24 次迭代后，函数值从 72.2666 下降到 -9.656。 5. 应用实例 5.1 弹簧系统优化 通过优化弹簧系统的势能函数，展示了各种优化算法的应用。弹簧系统的势能函数为： U=k1(x12+(x2+1)2−1)2+k2(x12+(x2−1)2−1)2−(Fx1x1+Fx2x2)U = k_1 \\left( \\sqrt{x_1^2 + (x_2 + 1)^2} - 1 \\right)^2 + k_2 \\left( \\sqrt{x_1^2 + (x_2 - 1)^2} - 1 \\right)^2 - (F_{x_1}x_1 + F_{x_2}x_2) U=k1​(x12​+(x2​+1)2​−1)2+k2​(x12​+(x2​−1)2​−1)2−(Fx1​​x1​+Fx2​​x2​) 通过优化算法，可以找到使势能最小的弹簧系统的平衡位置。 5.2 机器人运动设计 将 Powell 方法应用于机器人运动设计问题，通过优化关节角度，使得机器人末端执行器的运动轨迹与期望轨迹尽可能匹配。 6. 总结 本章详细介绍了无约束优化问题的求解方法，特别是基于梯度的优化方法（如梯度下降法、牛顿法）和非基于梯度的优化方法（如 Powell 方法、Nelder-Mead 算法）。通过对比梯度下降法和牛顿法，可以看出它们各有优缺点，实际应用中应根据问题的特点选择合适的优化方法。 梯度下降法：适合作为初始优化步骤，适合大规模问题。 牛顿法：适合小规模问题，特别是在接近极小值时具有快速收敛性。 第四章 线性规划 本章主要介绍了线性规划的基本概念、求解方法及其应用。线性规划问题的目标函数和约束条件都是设计变量的线性函数，广泛应用于各个领域，如航空公司的机组调度、投资组合优化、石油公司的生产计划等。以下是本章的详细解读，重点放在4.3节“线性规划的标准形式”。 1. 线性规划简介 线性规划问题的目标函数和约束条件都是设计变量的线性函数。线性函数满足以下性质： 加法性：f(x+y)=f(x)+f(y)f(x+y)=f(x)+f(y)f(x+y)=f(x)+f(y) 齐次性：f(kx)=kf(x)f(kx)=kf(x)f(kx)=kf(x) 线性规划问题通常包含大量的设计变量和约束条件，因此需要特殊的求解技术。本章介绍了线性规划的图形法、标准形式、基本解、单纯形法、对偶问题、对偶单纯形法以及内点法。 2. 图形法求解 图形法是一种简单的求解方法，适用于只有两到三个设计变量的线性规划问题。通过绘制约束条件的图形，可以找到可行域，并在可行域的顶点处找到目标函数的最优值。 示例： 考虑以下线性规划问题： Maximize z=x+2y\\text{Maximize } z = x + 2y Maximize z=x+2y 约束条件： 2x+y≥4−2x+4y≥−2−2x+y≥−8−2x+y≤−2y≤62x + y \\geq 4 \\\\ -2x + 4y \\geq -2 \\\\ -2x + y \\geq -8 \\\\ -2x + y \\leq -2 \\\\ y \\leq 6 2x+y≥4−2x+4y≥−2−2x+y≥−8−2x+y≤−2y≤6 通过绘制这些约束条件，可以得到可行域ABCDEABCDEABCDE。目标函数的最优值出现在可行域的顶点处，本例中最大值为19，对应的x=7x=7x=7，y=6y=6y=6。 3. 线性规划的标准形式（重点） 线性规划问题的标准形式是求解线性规划问题的基础。标准形式的要求如下： 目标函数为最小化类型： 如果原问题是最大化问题，可以通过将目标函数乘以-1转换为最小化问题。 例如，最大化z=x1+2x2z=x_1+2x_2z=x1​+2x2​可以转换为最小化−z=−x1−2x2-z=-x_1-2x_2−z=−x1​−2x2​。 所有设计变量非负： 如果某个变量xix_ixi​没有非负限制（即自由变量），可以通过引入两个非负变量xi′x_i&#x27;xi′​和xi′′x_i&#x27;&#x27;xi′′​来表示，即xi=xi′−xi′′x_i=x_i&#x27;-x_i&#x27;&#x27;xi​=xi′​−xi′′​，其中xi′≥0x_i&#x27;\\geq0xi′​≥0，xi′′≥0x_i&#x27;&#x27;\\geq0xi′′​≥0。 所有约束条件为等式形式： 如果约束条件是不等式，可以通过引入松弛变量或剩余变量将其转换为等式。 对于≤\\leq≤类型的约束，添加松弛变量si≥0s_i\\geq0si​≥0。 对于≥\\geq≥类型的约束，减去剩余变量ei≥0e_i\\geq0ei​≥0。 所有约束条件的右端项非负： 如果某个约束的右端项为负数，可以通过将整个约束乘以-1来使其变为非负。 示例： 将以下线性规划问题转换为标准形式： Maximize z=−4x1−2x2+x3−3x4\\text{Maximize } z = -4x_1 - 2x_2 + x_3 - 3x_4 Maximize z=−4x1​−2x2​+x3​−3x4​ 约束条件： 2x1+3x2−x3−3x4=5−5x1−2x2+4x3−7x4≤84x1−x2−2x3+5x4≤−6x1≥−1,0≤x2≤3,x3≥0,x4 自由2x_1 + 3x_2 - x_3 - 3x_4 = 5 \\\\ -5x_1 - 2x_2 + 4x_3 - 7x_4 \\leq 8 \\\\ 4x_1 - x_2 - 2x_3 + 5x_4 \\leq -6 \\\\ x_1 \\geq -1, 0 \\leq x_2 \\leq 3, x_3 \\geq 0, x_4 \\text{ 自由} 2x1​+3x2​−x3​−3x4​=5−5x1​−2x2​+4x3​−7x4​≤84x1​−x2​−2x3​+5x4​≤−6x1​≥−1,0≤x2​≤3,x3​≥0,x4​ 自由 转换步骤： 将目标函数转换为最小化形式：Minimize −z=4x1+2x2−x3+3x4\\text{Minimize } -z = 4x_1 + 2x_2 - x_3 + 3x_4 Minimize −z=4x1​+2x2​−x3​+3x4​ 处理约束条件： 第二个约束−5x1−2x2+4x3−7x4≤8-5x_1-2x_2+4x_3-7x_4\\leq8−5x1​−2x2​+4x3​−7x4​≤8可以通过添加松弛变量s1s_1s1​转换为等式：−5x1−2x2+4x3−7x4+s1=8-5x_1-2x_2+4x_3-7x_4+s_1=8 −5x1​−2x2​+4x3​−7x4​+s1​=8 第三个约束4x1−x2−2x3+5x4≤−64x_1-x_2-2x_3+5x_4\\leq-64x1​−x2​−2x3​+5x4​≤−6可以通过乘以-1转换为：−4x1+x2+2x3−5x4≥6-4x_1+x_2+2x_3-5x_4\\geq6 −4x1​+x2​+2x3​−5x4​≥6 然后减去剩余变量e2e_2e2​：−4x1+x2+2x3−5x4−e2=6-4x_1+x_2+2x_3-5x_4-e_2=6 −4x1​+x2​+2x3​−5x4​−e2​=6 处理自由变量x4x_4x4​： 引入x4′x_4&#x27;x4′​和x4′′x_4&#x27;&#x27;x4′′​，使得x4=x4′−x4′′x_4=x_4&#x27;-x_4&#x27;&#x27;x4​=x4′​−x4′′​，其中x4′≥0x_4&#x27;\\geq0x4′​≥0，x4′′≥0x_4&#x27;&#x27;\\geq0x4′′​≥0。 最终，问题转换为标准形式： Minimize z′=4x1′+2x2−x3+3x4′−3x4′′\\text{Minimize } z&#x27; = 4x_1&#x27; + 2x_2 - x_3 + 3x_4&#x27; - 3x_4&#x27;&#x27; Minimize z′=4x1′​+2x2​−x3​+3x4′​−3x4′′​ 约束条件： 2x1′+3x2−x3−3x4′+3x4′′=7−5x1′−2x2+4x3−7x4′+7x4′′+s1=8−4x1′+x2+2x3−5x4′+5x4′′−e2=6x2+s3=3x1′,x2,x3,x4′,x4′′,s1,e2,s3≥02x_1&#x27; + 3x_2 - x_3 - 3x_4&#x27; + 3x_4&#x27;&#x27; = 7 \\\\ -5x_1&#x27; - 2x_2 + 4x_3 - 7x_4&#x27; + 7x_4&#x27;&#x27; + s_1 = 8 \\\\ -4x_1&#x27; + x_2 + 2x_3 - 5x_4&#x27; + 5x_4&#x27;&#x27; - e_2 = 6 \\\\ x_2 + s_3 = 3 \\\\ x_1&#x27;, x_2, x_3, x_4&#x27;, x_4&#x27;&#x27;, s_1, e_2, s_3 \\geq 0 2x1′​+3x2​−x3​−3x4′​+3x4′′​=7−5x1′​−2x2​+4x3​−7x4′​+7x4′′​+s1​=8−4x1′​+x2​+2x3​−5x4′​+5x4′′​−e2​=6x2​+s3​=3x1′​,x2​,x3​,x4′​,x4′′​,s1​,e2​,s3​≥0 4. 基本解 对于标准形式的线性规划问题，基本解是通过将n−mn-mn−m个变量设为零，并求解约束方程组得到的解。如果基本解满足所有变量非负，则称为基本可行解。基本可行解是可行域的顶点。 示例： 考虑以下方程组： 3x1−4x2+2x3+x4=0x1+3x2+2x3+x4=5007x1+x2+x3−x4=7003x_1 - 4x_2 + 2x_3 + x_4 = 0 \\\\ x_1 + 3x_2 + 2x_3 + x_4 = 500 \\\\ 7x_1 + x_2 + x_3 - x_4 = 700 3x1​−4x2​+2x3​+x4​=0x1​+3x2​+2x3​+x4​=5007x1​+x2​+x3​−x4​=700 通过选择不同的基本变量和非基本变量，可以得到多个基本解，其中一些是基本可行解。 5. 单纯形法 单纯形法是一种迭代算法，通过从一个基本可行解移动到另一个基本可行解，直到找到最优解。单纯形法需要一个初始的基本可行解，通常通过引入人工变量来实现。 示例： 考虑以下线性规划问题： Maximize z=6x1+7x2\\text{Maximize } z = 6x_1 + 7x_2 Maximize z=6x1​+7x2​ 约束条件： 3x1+x2≤10x1+2x2≤8x1≤3x1,x2≥03x_1 + x_2 \\leq 10 \\\\ x_1 + 2x_2 \\leq 8 \\\\ x_1 \\leq 3 \\\\ x_1, x_2 \\geq 0 3x1​+x2​≤10x1​+2x2​≤8x1​≤3x1​,x2​≥0 通过引入松弛变量，将问题转换为标准形式，并使用单纯形法求解。最终得到的最优解为x1=125x_1=\\frac{12}{5}x1​=512​，x2=145x_2=\\frac{14}{5}x2​=514​，目标函数值为34。 6. 内点法 内点法通过在可行域内部移动来寻找最优解，适用于大规模线性规划问题。内点法包括障碍函数法、势能减少法和仿射缩放法。 示例： 使用仿射缩放法求解以下线性规划问题： Maximize z=6x1+7x2\\text{Maximize } z = 6x_1 + 7x_2 Maximize z=6x1​+7x2​ 约束条件： 3x1+x2≤10x1+2x2≤8x1≤3x1,x2≥03x_1 + x_2 \\leq 10 \\\\ x_1 + 2x_2 \\leq 8 \\\\ x_1 \\leq 3 \\\\ x_1, x_2 \\geq 0 3x1​+x2​≤10x1​+2x2​≤8x1​≤3x1​,x2​≥0 最终得到的最优解与单纯形法一致。 总结 本章详细介绍了线性规划的基本概念、求解方法及其应用。通过图形法、单纯形法、对偶单纯形法和内点法，可以有效地求解线性规划问题。线性规划在投资组合优化、生产计划、资源分配等领域有着广泛的应用。 第五章 引导随机搜索方法 1. 遗传算法（GA）的详细讲解 书本中的例子是太阳能测试问题，目标是最小化成本函数： U=204,165.5330−2T+10,400T−20U = \\frac{204,165.5}{330 - 2T} + \\frac{10,400}{T - 20} U=330−2T204,165.5​+T−2010,400​ 其中温度 TTT 的范围是 [40,90][40, 90][40,90]。 GA 的主要步骤： 初始化种群 适应度评估 选择 交叉 变异 迭代 详细步骤： 步骤 1：初始化种群 温度 TTT 的范围是 [40,90][40, 90][40,90]，我们需要将 TTT 编码为二进制字符串。 假设我们使用 15 位二进制字符串来表示 TTT，因为 215=327682^{15} = 32768215=32768，可以覆盖 [40,90][40, 90][40,90] 的范围，并且精度足够高。 随机生成 10 个个体（种群大小为 10），每个个体是一个 15 位二进制字符串。例如： 个体 1: 110110011000101 个体 2: 100001010111010 个体 3: 000110101110101 …（共 10 个个体） 步骤 2：适应度评估 将二进制字符串解码为实数值 TTT：Ti=Tmin+(Tmax−Tmin)⋅Decoded Value215−1T_i = T_{\\text{min}} + \\frac{(T_{\\text{max}} - T_{\\text{min}}) \\cdot \\text{Decoded Value}}{2^{15} - 1} Ti​=Tmin​+215−1(Tmax​−Tmin​)⋅Decoded Value​ 其中 Tmin=40T_{\\text{min}} = 40Tmin​=40，Tmax=90T_{\\text{max}} = 90Tmax​=90，Decoded Value 是二进制字符串对应的十进制值。 计算每个个体的适应度（即成本函数 UUU 的值）。例如： 个体 1: T=82.4894T = 82.4894T=82.4894，U=1403.6U = 1403.6U=1403.6 个体 2: T=66.0659T = 66.0659T=66.0659，U=1257.6U = 1257.6U=1257.6 个体 3: T=45.2568T = 45.2568T=45.2568，U=1264.3U = 1264.3U=1264.3 …（计算所有个体的适应度） 步骤 3：选择 使用轮盘赌选择法或锦标赛选择法选择优秀的个体进行繁殖。 轮盘赌选择法： 计算每个个体的选择概率：Pi=Fi∑FiP_i = \\frac{F_i}{\\sum F_i} Pi​=∑Fi​Fi​​ 其中 Fi=11+UiF_i = \\frac{1}{1 + U_i}Fi​=1+Ui​1​（因为我们要最小化 UUU，所以适应度 FiF_iFi​ 与 UiU_iUi​ 成反比）。 根据概率选择个体，适应度高的个体被选中的概率更大。 锦标赛选择法： 随机选择两个个体，比较它们的适应度，选择适应度更高的个体作为父代。 步骤 4：交叉 随机选择两个父代个体，进行单点交叉操作。例如： 父代 1: 110110011000101 父代 2: 100001010111010 交叉点在第 9 位： 子代 1: 110110010111010 子代 2: 100001011000101 步骤 5：变异 对子代个体进行变异操作，随机改变某些基因（0 变 1，1 变 0）。例如： 子代 1: 110110010111010 变异后: 110110010111110（第 13 位发生变异） 步骤 6：迭代 重复上述步骤，直到满足终止条件（如达到最大迭代次数或找到满意的解）。 2. 粒子群优化（PSO）的详细讲解 书本中的例子是Schwefel 函数，目标是最小化函数： f(x)=−x1sin⁡∣x1∣−x2sin⁡∣x2∣f(x) = -x_1 \\sin \\sqrt{|x_1|} - x_2 \\sin \\sqrt{|x_2|} f(x)=−x1​sin∣x1​∣​−x2​sin∣x2​∣​ 其中 x1x_1x1​ 和 x2x_2x2​ 的范围是 [−500,500][-500, 500][−500,500]。 PSO 的主要步骤： 初始化粒子群 适应度评估 更新个体最优和全局最优 更新速度和位置 迭代 详细步骤： 步骤 1：初始化粒子群 假设粒子群大小为 20，每个粒子的位置 x1x_1x1​ 和 x2x_2x2​ 在 [−500,500][-500, 500][−500,500] 范围内随机生成。例如： 粒子 1: x1=120.5x_1 = 120.5x1​=120.5，x2=−300.2x_2 = -300.2x2​=−300.2 粒子 2: x1=−450.3x_1 = -450.3x1​=−450.3，x2=200.7x_2 = 200.7x2​=200.7 …（共 20 个粒子） 步骤 2：适应度评估 计算每个粒子的适应度（即 Schwefel 函数值）。例如： 粒子 1: f(120.5,−300.2)=−120.5sin⁡∣120.5∣−(−300.2)sin⁡∣−300.2∣f(120.5, -300.2) = -120.5 \\sin \\sqrt{|120.5|} - (-300.2) \\sin \\sqrt{|-300.2|}f(120.5,−300.2)=−120.5sin∣120.5∣​−(−300.2)sin∣−300.2∣​ 粒子 2: f(−450.3,200.7)=−(−450.3)sin⁡∣−450.3∣−200.7sin⁡∣200.7∣f(-450.3, 200.7) = -(-450.3) \\sin \\sqrt{|-450.3|} - 200.7 \\sin \\sqrt{|200.7|}f(−450.3,200.7)=−(−450.3)sin∣−450.3∣​−200.7sin∣200.7∣​ …（计算所有粒子的适应度） 步骤 3：更新个体最优和全局最优 记录每个粒子的历史最优位置（pbestp_{\\text{best}}pbest​）和群体的历史最优位置（gbestg_{\\text{best}}gbest​）。 如果当前适应度优于 pbestp_{\\text{best}}pbest​，则更新 pbestp_{\\text{best}}pbest​。 如果当前适应度优于 gbestg_{\\text{best}}gbest​，则更新 gbestg_{\\text{best}}gbest​。 步骤 4：更新速度和位置 根据以下公式更新每个粒子的速度和位置：vi+1,k=w1vi,k+ϕ1(pbest,k−xi,k)ui+ϕ2(gbest−xi,k)uiv_{i+1,k} = w_1 v_{i,k} + \\phi_1 (p_{\\text{best},k} - x_{i,k}) u_i + \\phi_2 (g_{\\text{best}} - x_{i,k}) u_i vi+1,k​=w1​vi,k​+ϕ1​(pbest,k​−xi,k​)ui​+ϕ2​(gbest​−xi,k​)ui​ xi+1,k=xi,k+vi+1,kx_{i+1,k} = x_{i,k} + v_{i+1,k} xi+1,k​=xi,k​+vi+1,k​ 其中： vi,kv_{i,k}vi,k​ 是粒子的速度， pbest,kp_{\\text{best},k}pbest,k​ 是个体的历史最优位置， gbestg_{\\text{best}}gbest​ 是群体的历史最优位置， w1w_1w1​, ϕ1\\phi_1ϕ1​, ϕ2\\phi_2ϕ2​ 是算法的调优参数， uiu_iui​ 是随机数。 步骤 5：迭代 重复上述步骤，直到满足终止条件（如达到最大迭代次数或找到满意的解）。 八皇后问题简介 八皇后问题是一个经典的组合优化问题，目标是在一个 8x8 的国际象棋棋盘上放置 8 个皇后，使得它们互不攻击。具体规则如下： 行冲突：不能有两个皇后在同一行。 列冲突：不能有两个皇后在同一列。 对角线冲突：不能有两个皇后在同一对角线上。 3. 遗传算法（GA）解决八皇后问题 算法思路： 遗传算法模拟生物进化过程，通过选择、交叉和变异等操作逐步优化种群，最终找到最优解。 主要步骤： 初始化种群：随机生成一组个体（解）。 适应度评估：计算每个个体的适应度（冲突数越少，适应度越高）。 选择：根据适应度选择优秀个体进行繁殖。 交叉：通过交叉操作生成新个体。 变异：随机改变个体的某些基因。 迭代：重复上述步骤，直到找到解或达到最大迭代次数。 详细步骤： 步骤 1：初始化种群 随机生成 10 个个体（种群大小为 10），每个个体是一个长度为 8 的数组，数组的每个元素是 1 到 8 的随机整数。例如： 个体 1: [2, 4, 7, 1, 8, 5, 3, 6] 个体 2: [5, 3, 8, 2, 7, 1, 6, 4] 个体 3: [1, 7, 4, 6, 8, 2, 5, 3] 个体 4: [3, 6, 2, 5, 1, 8, 4, 7] 个体 5: [7, 2, 6, 3, 1, 4, 8, 5] 个体 6: [4, 8, 1, 5, 6, 2, 7, 3] 个体 7: [6, 1, 5, 2, 8, 3, 7, 4] 个体 8: [8, 3, 1, 6, 2, 5, 7, 4] 个体 9: [5, 7, 2, 6, 3, 1, 4, 8] 个体 10: [4, 1, 5, 8, 6, 3, 7, 2] 步骤 2：适应度评估 计算每个个体的适应度（即冲突数）。冲突数越少，适应度越高。 冲突数 = 行冲突数 + 列冲突数 + 对角线冲突数。 例如，个体 [2, 4, 7, 1, 8, 5, 3, 6] 的冲突数为 2（假设有两个冲突）。 适应度可以定义为：适应度=1/(1+冲突数)适应度 = 1 / (1 + 冲突数)适应度=1/(1+冲突数)。 计算所有个体的适应度： 个体 1: 冲突数 = 2，适应度 = 1/(1+2)=0.3331 / (1 + 2) = 0.3331/(1+2)=0.333 个体 2: 冲突数 = 1，适应度 = 1/(1+1)=0.51 / (1 + 1) = 0.51/(1+1)=0.5 个体 3: 冲突数 = 3，适应度 = 1/(1+3)=0.251 / (1 + 3) = 0.251/(1+3)=0.25 个体 4: 冲突数 = 0，适应度 = 1/(1+0)=1.01 / (1 + 0) = 1.01/(1+0)=1.0 个体 5: 冲突数 = 2，适应度 = 1/(1+2)=0.3331 / (1 + 2) = 0.3331/(1+2)=0.333 个体 6: 冲突数 = 1，适应度 = 1/(1+1)=0.51 / (1 + 1) = 0.51/(1+1)=0.5 个体 7: 冲突数 = 2，适应度 = 1/(1+2)=0.3331 / (1 + 2) = 0.3331/(1+2)=0.333 个体 8: 冲突数 = 3，适应度 = 1/(1+3)=0.251 / (1 + 3) = 0.251/(1+3)=0.25 个体 9: 冲突数 = 1，适应度 = 1/(1+1)=0.51 / (1 + 1) = 0.51/(1+1)=0.5 个体 10: 冲突数 = 2，适应度 = 1/(1+2)=0.3331 / (1 + 2) = 0.3331/(1+2)=0.333 步骤 3：选择 使用轮盘赌选择法选择优秀的个体进行繁殖。 计算每个个体的选择概率： 个体 1: 0.333/4.0=0.0830.333 / 4.0 = 0.0830.333/4.0=0.083 个体 2: 0.5/4.0=0.1250.5 / 4.0 = 0.1250.5/4.0=0.125 个体 3: 0.25/4.0=0.06250.25 / 4.0 = 0.06250.25/4.0=0.0625 个体 4: 1.0/4.0=0.251.0 / 4.0 = 0.251.0/4.0=0.25 个体 5: 0.333/4.0=0.0830.333 / 4.0 = 0.0830.333/4.0=0.083 个体 6: 0.5/4.0=0.1250.5 / 4.0 = 0.1250.5/4.0=0.125 个体 7: 0.333/4.0=0.0830.333 / 4.0 = 0.0830.333/4.0=0.083 个体 8: 0.25/4.0=0.06250.25 / 4.0 = 0.06250.25/4.0=0.0625 个体 9: 0.5/4.0=0.1250.5 / 4.0 = 0.1250.5/4.0=0.125 个体 10: 0.333/4.0=0.0830.333 / 4.0 = 0.0830.333/4.0=0.083 根据概率选择个体，适应度高的个体被选中的概率更大。 步骤 4：交叉 随机选择两个父代个体，进行单点交叉操作。例如： 父代 1: [2, 4, 7, 1, 8, 5, 3, 6] 父代 2: [5, 3, 8, 2, 7, 1, 6, 4] 交叉点在第 4 位： 子代 1: [2, 4, 7, 2, 7, 1, 6, 4] 子代 2: [5, 3, 8, 1, 8, 5, 3, 6] 步骤 5：变异 对子代个体进行变异操作，随机改变某些基因（列位置）。例如： 子代 1: [2, 4, 7, 2, 7, 1, 6, 4] 变异后: [2, 4, 7, 2, 7, 1, 6, 8]（第 8 位发生变异） 步骤 6：迭代 重复上述步骤，直到找到冲突数为 0 的解（即找到八皇后问题的解）。 Python 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import random# 定义棋盘大小N = 8# 初始化种群def initialize_population(pop_size): &quot;&quot;&quot; 随机生成一组个体（解），每个个体是一个长度为 N 的列表，表示每行皇后的列位置。 &quot;&quot;&quot; return [random.sample(range(1, N + 1), N) for _ in range(pop_size)]# 计算冲突数def calculate_conflicts(individual): &quot;&quot;&quot; 计算一个个体（解）的冲突数。 &quot;&quot;&quot; conflicts = 0 for i in range(N): for j in range(i + 1, N): # 检查列冲突和对角线冲突 if individual[i] == individual[j] or abs(individual[i] - individual[j]) == abs(i - j): conflicts += 1 return conflicts# 计算适应度def fitness(individual): &quot;&quot;&quot; 计算一个个体（解）的适应度，冲突数越少，适应度越高。 &quot;&quot;&quot; return 1 / (1 + calculate_conflicts(individual))# 选择（轮盘赌选择法）def selection(population, fitness_values): &quot;&quot;&quot; 根据适应度选择优秀个体进行繁殖。 &quot;&quot;&quot; total_fitness = sum(fitness_values) probabilities = [f / total_fitness for f in fitness_values] selected = random.choices(population, weights=probabilities, k=len(population)) return selected# 交叉（单点交叉）def crossover(parent1, parent2): &quot;&quot;&quot; 通过单点交叉生成两个子代个体。 &quot;&quot;&quot; point = random.randint(1, N - 1) child1 = parent1[:point] + parent2[point:] child2 = parent2[:point] + parent1[point:] return child1, child2# 变异（随机改变一个基因）def mutate(individual): &quot;&quot;&quot; 随机改变一个个体（解）的某个基因（列位置）。 &quot;&quot;&quot; idx = random.randint(0, N - 1) individual[idx] = random.randint(1, N) return individual# 遗传算法主函数def genetic_algorithm(pop_size, max_generations): &quot;&quot;&quot; 遗传算法主函数。 &quot;&quot;&quot; population = initialize_population(pop_size) for generation in range(max_generations): # 计算适应度 fitness_values = [fitness(ind) for ind in population] # 检查是否有解 best_individual = population[fitness_values.index(max(fitness_values))] if calculate_conflicts(best_individual) == 0: print(f&quot;Solution found in generation &#123;generation&#125;: &#123;best_individual&#125;&quot;) return best_individual # 选择 selected = selection(population, fitness_values) # 交叉 next_population = [] for i in range(0, pop_size, 2): parent1, parent2 = selected[i], selected[i + 1] child1, child2 = crossover(parent1, parent2) next_population.extend([child1, child2]) # 变异 population = [mutate(ind) for ind in next_population] print(&quot;No solution found.&quot;) return None# 运行遗传算法genetic_algorithm(pop_size=10, max_generations=1000) 4. 粒子群优化（PSO）解决八皇后问题 算法思路： 粒子群优化模拟鸟群或鱼群的集体行为，通过个体和群体的历史最优位置更新搜索方向，逐步找到最优解。 主要步骤： 初始化粒子群：随机生成一组粒子（解）。 适应度评估：计算每个粒子的适应度（冲突数越少，适应度越高）。 更新个体最优和全局最优：记录每个粒子的历史最优位置和群体的历史最优位置。 更新速度和位置：根据个体最优和全局最优更新粒子的速度和位置。 迭代：重复上述步骤，直到找到解或达到最大迭代次数。 详细步骤： 步骤 1：初始化粒子群 随机生成 10 个粒子（粒子群大小为 10），每个粒子是一个长度为 8 的数组，数组的每个元素是 1 到 8 的随机整数。例如： 粒子 1: [2, 4, 7, 1, 8, 5, 3, 6] 粒子 2: [5, 3, 8, 2, 7, 1, 6, 4] 粒子 3: [1, 7, 4, 6, 8, 2, 5, 3] 粒子 4: [3, 6, 2, 5, 1, 8, 4, 7] 粒子 5: [7, 2, 6, 3, 1, 4, 8, 5] 粒子 6: [4, 8, 1, 5, 6, 2, 7, 3] 粒子 7: [6, 1, 5, 2, 8, 3, 7, 4] 粒子 8: [8, 3, 1, 6, 2, 5, 7, 4] 粒子 9: [5, 7, 2, 6, 3, 1, 4, 8] 粒子 10: [4, 1, 5, 8, 6, 3, 7, 2] 步骤 2：适应度评估 计算每个粒子的适应度（即冲突数）。冲突数越少，适应度越高。 冲突数 = 行冲突数 + 列冲突数 + 对角线冲突数。 例如，粒子 [2, 4, 7, 1, 8, 5, 3, 6] 的冲突数为 2（假设有两个冲突）。 适应度可以定义为：适应度=1/(1+冲突数)适应度 = 1 / (1 + 冲突数)适应度=1/(1+冲突数)。 计算所有粒子的适应度： 粒子 1: 冲突数 = 2，适应度 = 1/(1+2)=0.3331 / (1 + 2) = 0.3331/(1+2)=0.333 粒子 2: 冲突数 = 1，适应度 = 1/(1+1)=0.51 / (1 + 1) = 0.51/(1+1)=0.5 粒子 3: 冲突数 = 3，适应度 = 1/(1+3)=0.251 / (1 + 3) = 0.251/(1+3)=0.25 粒子 4: 冲突数 = 0，适应度 = 1/(1+0)=1.01 / (1 + 0) = 1.01/(1+0)=1.0 粒子 5: 冲突数 = 2，适应度 = 1/(1+2)=0.3331 / (1 + 2) = 0.3331/(1+2)=0.333 粒子 6: 冲突数 = 1，适应度 = 1/(1+1)=0.51 / (1 + 1) = 0.51/(1+1)=0.5 粒子 7: 冲突数 = 2，适应度 = 1/(1+2)=0.3331 / (1 + 2) = 0.3331/(1+2)=0.333 粒子 8: 冲突数 = 3，适应度 = 1/(1+3)=0.251 / (1 + 3) = 0.251/(1+3)=0.25 粒子 9: 冲突数 = 1，适应度 = 1/(1+1)=0.51 / (1 + 1) = 0.51/(1+1)=0.5 粒子 10: 冲突数 = 2，适应度 = 1/(1+2)=0.3331 / (1 + 2) = 0.3331/(1+2)=0.333 步骤 3：更新个体最优和全局最优 记录每个粒子的历史最优位置（pbestp_{\\text{best}}pbest​）和群体的历史最优位置（gbestg_{\\text{best}}gbest​）。 如果当前适应度优于 pbestp_{\\text{best}}pbest​，则更新 pbestp_{\\text{best}}pbest​。 如果当前适应度优于 gbestg_{\\text{best}}gbest​，则更新 gbestg_{\\text{best}}gbest​。 步骤 4：更新速度和位置 根据以下公式更新每个粒子的速度和位置：vi+1,k=w1vi,k+ϕ1(pbest,k−xi,k)ui+ϕ2(gbest−xi,k)uiv_{i+1,k} = w_1 v_{i,k} + \\phi_1 (p_{\\text{best},k} - x_{i,k}) u_i + \\phi_2 (g_{\\text{best}} - x_{i,k}) u_i vi+1,k​=w1​vi,k​+ϕ1​(pbest,k​−xi,k​)ui​+ϕ2​(gbest​−xi,k​)ui​ xi+1,k=xi,k+vi+1,kx_{i+1,k} = x_{i,k} + v_{i+1,k} xi+1,k​=xi,k​+vi+1,k​ 其中： vi,kv_{i,k}vi,k​ 是粒子的速度， pbest,kp_{\\text{best},k}pbest,k​ 是个体的历史最优位置， gbestg_{\\text{best}}gbest​ 是群体的历史最优位置， w1w_1w1​, ϕ1\\phi_1ϕ1​, ϕ2\\phi_2ϕ2​ 是算法的调优参数， uiu_iui​ 是随机数。 步骤 5：迭代 重复上述步骤，直到找到冲突数为 0 的解（即找到八皇后问题的解）。 Python 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import random# 定义棋盘大小N = 8# 初始化粒子群def initialize_particles(pop_size): &quot;&quot;&quot; 随机生成一组粒子（解），每个粒子是一个长度为 N 的列表，表示每行皇后的列位置。 &quot;&quot;&quot; return [random.sample(range(1, N + 1), N) for _ in range(pop_size)]# 计算冲突数def calculate_conflicts(individual): &quot;&quot;&quot; 计算一个粒子（解）的冲突数。 &quot;&quot;&quot; conflicts = 0 for i in range(N): for j in range(i + 1, N): # 检查列冲突和对角线冲突 if individual[i] == individual[j] or abs(individual[i] - individual[j]) == abs(i - j): conflicts += 1 return conflicts# 计算适应度def fitness(individual): &quot;&quot;&quot; 计算一个粒子（解）的适应度，冲突数越少，适应度越高。 &quot;&quot;&quot; return 1 / (1 + calculate_conflicts(individual))# 更新速度和位置def update_velocity_position(particle, pbest, gbest, velocity, w, c1, c2): &quot;&quot;&quot; 更新粒子的速度和位置。 &quot;&quot;&quot; new_velocity = [] new_particle = [] for i in range(N): # 更新速度 v = w * velocity[i] + c1 * random.random() * (pbest[i] - particle[i]) + c2 * random.random() * (gbest[i] - particle[i]) # 限制速度范围 v = max(-N, min(N, v)) new_velocity.append(v) # 更新位置 new_pos = particle[i] + v # 限制位置范围 new_pos = max(1, min(N, new_pos)) new_particle.append(int(new_pos)) return new_velocity, new_particle# 粒子群优化主函数def pso(pop_size, max_iterations, w, c1, c2): &quot;&quot;&quot; 粒子群优化主函数。 &quot;&quot;&quot; particles = initialize_particles(pop_size) velocities = [[0] * N for _ in range(pop_size)] pbest = particles.copy() gbest = min(particles, key=lambda x: calculate_conflicts(x)) for iteration in range(max_iterations): for i in range(pop_size): # 更新速度和位置 velocities[i], particles[i] = update_velocity_position(particles[i], pbest[i], gbest, velocities[i], w, c1, c2) # 更新个体最优 if fitness(particles[i]) &gt; fitness(pbest[i]): pbest[i] = particles[i] # 更新全局最优 if fitness(particles[i]) &gt; fitness(gbest): gbest = particles[i] # 检查是否有解 if calculate_conflicts(gbest) == 0: print(f&quot;Solution found in iteration &#123;iteration&#125;: &#123;gbest&#125;&quot;) return gbest print(&quot;No solution found.&quot;) return None# 运行粒子群优化pso(pop_size=10, max_iterations=1000, w=0.5, c1=1.5, c2=1.5) 总结 通过书本中的例子，我们可以看到： 遗传算法（GA） 通过模拟生物进化过程，利用选择、交叉和变异等操作优化种群，适用于复杂的多模态优化问题。 粒子群优化（PSO） 通过模拟群体智能，利用个体和群体的历史最优位置更新搜索方向，适用于连续优化问题。 这两种方法在处理复杂、多模态的优化问题时表现出色，尤其适用于传统梯度方法难以处理的情况。通过具体的示例，我们可以更好地理解 GA 和 PSO 的运行过程。 第六章 约束优化 问题定义 目标函数： f(x)=(x1−1)2+(x2−2)2f(x) = (x_1 - 1)^2 + (x_2 - 2)^2 f(x)=(x1​−1)2+(x2​−2)2 约束条件： 等式约束：$ h_1(x) = 2x_1 - x_2 = 0 $ 不等式约束：$ g_1(x) = x_1 - 5 \\leq 0 $ 初始点： x(0)=(10,−5)x^{(0)} = (10, -5) x(0)=(10,−5) 迭代 1 我们从初始点 x(0)=(10,−5)x^{(0)} = (10, -5)x(0)=(10,−5) 开始。 1. 梯度计算 1.1 目标函数的梯度 ∇f(x)=[2(x1−1)2(x2−2)] abla f(x) = \\begin{bmatrix} 2(x_1 - 1) \\\\ 2(x_2 - 2) \\end{bmatrix} ∇f(x)=[2(x1​−1)2(x2​−2)​] 在 x(0)=(10,−5)x^{(0)} = (10, -5)x(0)=(10,−5) 处： ∇f(x(0))=[2(10−1)2(−5−2)]=[18−14] abla f(x^{(0)}) = \\begin{bmatrix} 2(10 - 1) \\\\ 2(-5 - 2) \\end{bmatrix} = \\begin{bmatrix} 18 \\\\ -14 \\end{bmatrix} ∇f(x(0))=[2(10−1)2(−5−2)​]=[18−14​] 1.2 等式约束的梯度 ∇h1(x)=[2−1] abla h_1(x) = \\begin{bmatrix} 2 \\\\ -1 \\end{bmatrix} ∇h1​(x)=[2−1​] 1.3 不等式约束的梯度 ∇g1(x)=[10] abla g_1(x) = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} ∇g1​(x)=[10​] 2. 二次规划 (QP) 子问题的构造 构造二次规划问题： min⁡p12pTHkp+∇f(x(k))Tp\\min_p \\quad \\frac{1}{2} p^T H_k p + abla f(x^{(k)})^T p pmin​21​pTHk​p+∇f(x(k))Tp subject to:∇h1(x(k))Tp+h1(x(k))=0∇g1(x(k))Tp+g1(x(k))≤0\\text{subject to:} \\quad \\begin{aligned} &amp; abla h_1(x^{(k)})^T p + h_1(x^{(k)}) = 0 \\\\ &amp; abla g_1(x^{(k)})^T p + g_1(x^{(k)}) \\leq 0 \\end{aligned} subject to:​∇h1​(x(k))Tp+h1​(x(k))=0∇g1​(x(k))Tp+g1​(x(k))≤0​ 2.1 Hessian 矩阵 目标函数的 Hessian 为： ∇2f(x)=[2002] abla^2 f(x) = \\begin{bmatrix} 2 &amp; 0 \\\\ 0 &amp; 2 \\end{bmatrix} ∇2f(x)=[20​02​] 由于约束是线性的，其 Hessian 为零。因此： Hk=[2002]H_k = \\begin{bmatrix} 2 &amp; 0 \\\\ 0 &amp; 2 \\end{bmatrix} Hk​=[20​02​] 2.2 线性化约束 在 x(0)=(10,−5)x^{(0)} = (10, -5)x(0)=(10,−5) 处： 等式约束： h1(x(0))=2(10)−(−5)=25h_1(x^{(0)}) = 2(10) - (-5) = 25 h1​(x(0))=2(10)−(−5)=25 ∇h1(x(0))Tp+h1(x(0))=2p1−p2+25=0 abla h_1(x^{(0)})^T p + h_1(x^{(0)}) = 2p_1 - p_2 + 25 = 0 ∇h1​(x(0))Tp+h1​(x(0))=2p1​−p2​+25=0 不等式约束： g1(x(0))=10−5=5g_1(x^{(0)}) = 10 - 5 = 5 g1​(x(0))=10−5=5 ∇g1(x(0))Tp+g1(x(0))=p1+5≤0 abla g_1(x^{(0)})^T p + g_1(x^{(0)}) = p_1 + 5 \\leq 0 ∇g1​(x(0))Tp+g1​(x(0))=p1​+5≤0 2.3 子问题的形式 将以上代入，我们的二次规划子问题为： min⁡p12[p1p2]T[2002][p1p2]+[18−14]T[p1p2]\\min_p \\quad \\frac{1}{2} \\begin{bmatrix} p_1 \\\\ p_2 \\end{bmatrix}^T \\begin{bmatrix} 2 &amp; 0 \\\\ 0 &amp; 2 \\end{bmatrix} \\begin{bmatrix} p_1 \\\\ p_2 \\end{bmatrix} + \\begin{bmatrix} 18 \\\\ -14 \\end{bmatrix}^T \\begin{bmatrix} p_1 \\\\ p_2 \\end{bmatrix} pmin​21​[p1​p2​​]T[20​02​][p1​p2​​]+[18−14​]T[p1​p2​​] subject to:2p1−p2+25=0p1+5≤0\\text{subject to:} \\begin{aligned} &amp; 2p_1 - p_2 + 25 = 0 \\\\ &amp; p_1 + 5 \\leq 0 \\end{aligned} subject to:​2p1​−p2​+25=0p1​+5≤0​ 2.4 求解子问题 拉格朗日函数： L(p,λ,μ)=p12+p22+18p1−14p2+λ(2p1−p2+25)+μ(p1+5)L(p, \\lambda, \\mu) = p_1^2 + p_2^2 + 18p_1 - 14p_2 + \\lambda (2p_1 - p_2 + 25) + \\mu (p_1 + 5) L(p,λ,μ)=p12​+p22​+18p1​−14p2​+λ(2p1​−p2​+25)+μ(p1​+5) 对 p1,p2p_1, p_2p1​,p2​ 求偏导： ∂L∂p1=2p1+18+2λ+μ=0⇒p1=−9−λ−μ2\\frac{\\partial L}{\\partial p_1} = 2p_1 + 18 + 2\\lambda + \\mu = 0 \\quad \\Rightarrow \\quad p_1 = -9 - \\lambda - \\frac{\\mu}{2} ∂p1​∂L​=2p1​+18+2λ+μ=0⇒p1​=−9−λ−2μ​ ∂L∂p2=2p2−14−λ=0⇒p2=7+λ2\\frac{\\partial L}{\\partial p_2} = 2p_2 - 14 - \\lambda = 0 \\quad \\Rightarrow \\quad p_2 = 7 + \\frac{\\lambda}{2} ∂p2​∂L​=2p2​−14−λ=0⇒p2​=7+2λ​ 带入约束： 2p1−p2+25=02p_1 - p_2 + 25 = 0 2p1​−p2​+25=0 和 p1+5≤0p_1 + 5 \\leq 0 p1​+5≤0 解得： p1=−5,p2=15p_1 = -5, \\quad p_2 = 15 p1​=−5,p2​=15 3. 更新点 更新公式： x(1)=x(0)+αpx^{(1)} = x^{(0)} + \\alpha p x(1)=x(0)+αp 假设步长 α=1\\alpha = 1α=1： x(1)=(10,−5)+1⋅(−5,15)=(5,10)x^{(1)} = (10, -5) + 1 \\cdot (-5, 15) = (5, 10) x(1)=(10,−5)+1⋅(−5,15)=(5,10) 迭代 2 以 x(1)=(5,10)x^{(1)} = (5, 10)x(1)=(5,10) 继续迭代。 1. 梯度计算 目标函数梯度： ∇f(x(1))=[2(5−1)2(10−2)]=[816] abla f(x^{(1)}) = \\begin{bmatrix} 2(5 - 1) \\\\ 2(10 - 2) \\end{bmatrix} = \\begin{bmatrix} 8 \\\\ 16 \\end{bmatrix} ∇f(x(1))=[2(5−1)2(10−2)​]=[816​] 等式约束梯度： ∇h1(x(1))=[2−1] abla h_1(x^{(1)}) = \\begin{bmatrix} 2 \\\\ -1 \\end{bmatrix} ∇h1​(x(1))=[2−1​] 不等式约束梯度： ∇g1(x(1))=[10] abla g_1(x^{(1)}) = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} ∇g1​(x(1))=[10​] 2. 构造二次规划子问题 新的二次规划问题如下： Hessian: Hk=[2002]H_k = \\begin{bmatrix} 2 &amp; 0 \\\\ 0 &amp; 2 \\end{bmatrix} Hk​=[20​02​] 线性化约束： 等式约束： h1(x(1))=2(5)−10=0h_1(x^{(1)}) = 2(5) - 10 = 0 h1​(x(1))=2(5)−10=0 ∇h1(x(1))Tp+h1(x(1))=2p1−p2=0 abla h_1(x^{(1)})^T p + h_1(x^{(1)}) = 2p_1 - p_2 = 0 ∇h1​(x(1))Tp+h1​(x(1))=2p1​−p2​=0 不等式约束： g1(x(1))=5−5=0g_1(x^{(1)}) = 5 - 5 = 0 g1​(x(1))=5−5=0 ∇g1(x(1))Tp+g1(x(1))=p1≤0 abla g_1(x^{(1)})^T p + g_1(x^{(1)}) = p_1 \\leq 0 ∇g1​(x(1))Tp+g1​(x(1))=p1​≤0 解得： p1=−4,p2=−8p_1 = -4, \\quad p_2 = -8 p1​=−4,p2​=−8 3. 更新点 x(2)=x(1)+αp=(5,10)+(−4,−8)=(1,2)x^{(2)} = x^{(1)} + \\alpha p = (5, 10) + (-4, -8) = (1, 2) x(2)=x(1)+αp=(5,10)+(−4,−8)=(1,2) 收敛 在 x(2)=(1,2)x^{(2)} = (1, 2)x(2)=(1,2) 处： 梯度为零： ∇f(x(2))=[00] abla f(x^{(2)}) = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} ∇f(x(2))=[00​] 满足约束条件： h1(x(2))=2(1)−2=0h_1(x^{(2)}) = 2(1) - 2 = 0 h1​(x(2))=2(1)−2=0 g1(x(2))=1−5≤0g_1(x^{(2)}) = 1 - 5 \\leq 0 g1​(x(2))=1−5≤0 因此 x∗=(1,2)x^* = (1, 2)x∗=(1,2) 是最终解。","tags":["湘潭大学","考试资料"],"categories":["湘潭大学计算机研究生课程","优化理论-肖赤心"]},{"title":"模式识别考点","path":"/posts/33183.html","content":"一、简答题 1.简述kmeans基本步骤，参数k如何选择。 从数据中选择 k 个对象作为初始聚类中心； 将样本集按照最小距离原则分配到最邻近聚类 使用每个聚类的样本均值更新聚类中心； 重复步骤（2）、（3），直到聚类中心不再发生变化； 输出最终的聚类中心和 k 个簇划分； k值可以根据领域知识来选择。例如，如果知道数据集中有多少个类别，就可以选择相应的k值。肘部法则和轮廓系数法也是常用的方法。 2.什么是模式识别，模式识别有什么意义。 定义：是通过计算机用数学技术方法来研究模式的自动处理和判读。是对表征事物或现象的各种形式的(数值的、文字的和逻辑关系的)信息进行处理和分析，以对事物或现象进行描述、辨认、分类和解释的过程，是信息科学和人工智能的重要组成部分。 意义：人们为了掌握客观事物，按事物相似的程度组成类别。模式识别的作用和目的就在于面对某一具体事物时将其正确地归入某一类别。 3.模式识别预处理有哪些基本内容 预处理是以去除噪声、加强有用的信息为目的, 并对输入测量仪器或其他因素所造成的退化现象进行复原的过程。 预处理一般有两种情况: 一是使数据的质量更好，比如用一些数字信号处理的方法去除信号中的噪声, 或者对一幅模糊的图像进行图像增强等, 确保有利于后期的模式识别工作； 另一种预处理是样本集的预处理, 比如样本集中异常值的剔除、类别的合并或分裂等。这一工作一般可以根据领域的专门知识进行, 也可以采用模式识别中的一些技术, 比如在进行后续工作之前先对样本集进行一次聚类分析。 4.最大似然方法和贝叶斯估计方法的差异 第一，最大似然方法预测时使用θ的点估计，贝叶斯方法使用θ的全分布。即最大似然求出最可能的θ值，而贝叶斯则是求解θ的分布。 第二，贝叶斯推断还引入了先验，通过先验和似然来求解后验分布，而最大似然直接使用似然函数，通过最大化其来求解。 5.简述svm的基本思想 支持向量机（support vector machines）是一种二分类模型，它的目的是寻找一个超平面来对样本进行分类，分类的原理是间隔最大化，最终转化为一个凸二次规划问题来求解，由简至繁的模型包括： 当训练样本线性可分时，通过硬间隔最大化，学习一个线性可分支持向量机； 当训练样本近似线性可分时，通过软间隔最大化，学习一个线性可分的支持向量机； 当训练样本线性不可分时，通过核函数和软间隔最大化，学习一个非线性支持向量机； 6.神经网络训练时是否可以将所有的参数初始化为0，为什么 不可以 对称性问题： 如果所有权重都初始化为相同的值，每个神经元学到的梯度将是相同的，导致所有神经元对应的权重在训练中都更新为相同的值，进而失去网络的表达能力。 梯度更新问题： 初始化所有权重为相同的值会导致反向传播中每个权重都接收相同的梯度，这样在权重更新时会使得所有权重按相同的步长进行更新，而不论它们在模型中的位置。 7.sigmod作为激烈(jilie)函数有什么缺点。 梯度消失： Sigmoid函数在其输入非常大或非常小的情况下，导数趋于零，导致梯度消失问题。在反向传播时，梯度趋近于零，使得权重更新变得非常缓慢，导致训练过程变得很慢。 输出不以零为中心： Sigmoid的输出范围是(0, 1)，因此其输出不以零为中心。这可能导致一些神经元在训练过程中出现偏置，从而使得某些神经元始终保持非常小的梯度。 幂运算相对耗时。 8.简述k近邻分类方法 k近邻（k-Nearest Neighbors，简称k-NN）是一种基本的监督学习算法，主要用于分类问题。其基本思想是通过测量不同样本之间的距离，将一个新样本分配给距离最近的k个已知类别样本中最常见的类别。k-NN方法的简述如下： 存储所有已知类别的样本。 对于一个新样本，计算其与所有已知类别的样本的距离。 从所有已知类别的样本中选择距离最近的k个样本。 统计这k个样本中各个类别的出现次数，将出现次数最多的类别作为新样本的预测类别。 9.2006年以后使得深度神经网络得到快速应用的技术突破在哪里，举四个例子 GPU计算的广泛应用： 通用图形处理单元（GPU）在深度学习训练中的应用使得计算速度显著提升，加速了深度神经网络的训练过程。 自监督学习和强化学习的兴起： 自监督学习和强化学习等新兴学习范式为深度学习提供了更多的学习方式，扩展了深度神经网络在不同领域的应用。 开源深度学习框架： 出现了多个开源深度学习框架，如TensorFlow和PyTorch，简化了深度学习模型的实现和训练过程，促进了更广泛的研究和应用。 10.隐马尔可夫模型三个核心问题 **评估问题：**给定一个HHM的模型和观测序列，如何高效的计算此模型产生的观测序列的概率。 **解码问题：**给定一个HHM的模型和观测序列，如何选择对应最佳的序列，使它在某状态下最优（出现的概率最大），比较好地解释观测值。 训练问题：给定观测序列，如何调整模型参数，以使得观察序列出现的概率最大化。","tags":["湘潭大学","考试资料"],"categories":["湘潭大学计算机研究生课程","模式识别-陈殊"]},{"title":"数理逻辑2024年试卷","path":"/posts/7896.html","content":"湘潭大学-计算机的数学基础（数理逻辑）2024考试原题 参考教材与习题答案：国防科技大学《数理逻辑》1991年出版 pdf链接： XTU-Graduate-CS-Course/计算机的数学基础-姜新文 at main · oymaster/XTU-Graduate-CS-Course 考试形式：开卷 2024原题： 一、计算题 下面哪个不是定理，为什么？ (1) (p∨q)⊃p (2) ∀xA(x)⊃∀yA(y) (3) ∃xA(x)⊃∀xA(x) 将公式 (¬p∨¬q)∧r 化成与之等价且仅含联结词 (→,¬) 的形式。 （教材P37） 二、证明题（教材P119) 证明，F系统中，⊨A当且仅当 ⊨∀xA 三、证明题（教材P118) 证明ii) 四、证明题（教材P89) 证明：","tags":["湘潭大学","考试资料"],"categories":["湘潭大学计算机研究生课程","计算机的数学基础-姜新文"]},{"title":"高级人工智能2024年试卷","path":"/posts/48030.html","content":"湘潭大学-高级人工智能2024考试原题 开卷考试 24年人工智能专家获得诺贝尔奖，获得者是谁，学术贡献是什么 机器学习就是学习数据，当标注数据不够时，可用的学习策略 显著性排序是什么，设计一个算法实现显著性排序，讨论它面临的挑战 有个公司有5个员工，需要设计一个人脸识别系统，设计用前馈神经网络，设计网络拓扑，画出神经网络图形，输入层输出层神经元个数，隐含层个数，分析用什么算法训练权重参数。讨论人脸安防系统的挑战与困难 空间智能是通往AGI的一大技术，浅述空间智能的实现路径","tags":["湘潭大学","考试资料"],"categories":["湘潭大学计算机研究生课程","高级人工智能-肖芬"]},{"title":"C++Primer5th 第十六章1","path":"/posts/12036.html","content":"实现智能指针 一、实现shared_ptr 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#ifndef MY_SHARED_PTR#define MY_SHARED_PTR#include&lt;iostream&gt;#include&lt;functional&gt;template &lt;typename T&gt;class mySharedPtr&#123;private: T *ptr; std::function&lt;void(T*)&gt; deleter; int *ref_count; //释放资源 void release()&#123; if(--(*ref_count)==0)&#123; if(deleter) deleter(ptr); else&#123; std::cerr&lt;&lt;&quot;mySharedPtr default delete &quot;; delete ptr; &#125; delete ref_count; &#125; &#125;public: //默认构造 explicit mySharedPtr(T *p,std::function&lt;void(T*)&gt;d = nullptr): ptr(p),ref_count(new int(1)),deleter(d)&#123;&#125; //拷贝构造 mySharedPtr(const mySharedPtr &amp;other):ptr(other.ptr),ref_count(other.ref_count),deleter(other.deleter)&#123; ++(*ref_count); &#125; //赋值 mySharedPtr&amp; operator=(const mySharedPtr&amp;other)&#123; if(this!=&amp;other)&#123; release();//先释放自己的资源，避免内存泄漏 ptr=other.ptr; ref_count=other.ref_count; deleter=other.deleter; //sharedptr不需要清空other的内容，他们需要共享指针和引用计数 ++(*ref_count); &#125; return *this; &#125; //移动构造 mySharedPtr (mySharedPtr &amp;&amp; other) noexcept :ptr(other.ptr),ref_count(other.ref_count),deleter(other.deleter)&#123; other.ptr=nullptr; other.ref_count=nullptr; &#125; //移动赋值 mySharedPtr&amp; operator=(mySharedPtr &amp;&amp; other) noexcept&#123; if(this!=&amp;other)&#123; //防止内存泄漏 release(); ptr==other.ptr; ref_count=other.ref_count; deleter=other.deleter; //移动赋值需要清空other，因为此时是把所有资源转移了 other.ptr=nullptr; other.ref_count=nullptr; &#125; return *this; &#125; ~mySharedPtr()&#123; release(); &#125; //加个const防止修改本对象的指针 T *get() const &#123;return ptr;&#125;&#125;;#endif 二、实现unique_ptr 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#ifndef MY_UNIQUE_PTR#define MY_UNIQUE_PTR#include&lt;iostream&gt;#include&lt;functional&gt;template&lt;typename T&gt;class myUniquePtr&#123;private: T *ptr; std::function&lt;void(T *)&gt; deleter;public: //默认构造 explicit myUniquePtr(T *p,std::function&lt;void(T*)&gt;d = nullptr): ptr(p),deleter(d)&#123;&#125; //禁止拷贝构造 myUniquePtr(const myUniquePtr &amp;)=delete; //禁止赋值 myUniquePtr&amp; operator=(const myUniquePtr&amp;) = delete; //移动构造 myUniquePtr (myUniquePtr &amp;&amp; other) noexcept :ptr(other.ptr),deleter(other.deleter)&#123; other.ptr=nullptr; &#125; //移动赋值 myUniquePtr&amp; operator=(myUniquePtr &amp;&amp; other) noexcept&#123; if(this!=&amp;other)&#123; //防止内存泄漏 if(deleter) deleter(ptr); else delete ptr; ptr=other.ptr; deleter=other.deleter; other.ptr=nullptr; &#125; return *this; &#125; ~myUniquePtr()&#123; if(deleter) deleter(ptr); else &#123; std::cerr&lt;&lt;&quot;myUniquePtr default delete &quot;; delete ptr; &#125; &#125; //加个防止修改本对象的指针 T *get() const &#123;return ptr;&#125;&#125;;#endif 三、debugDelete删除器 1234567891011121314151617#include &lt;iostream&gt;#ifndef DEBUG_DELETE#define DEBUG_DELETEclass debugDelete&#123;private: std::ostream&amp; os;public: debugDelete(std::ostream&amp; s=std::cerr):os(s)&#123;&#125; template&lt;typename T&gt; void operator() (T *p) const &#123; os&lt;&lt;&quot;debug delete &quot;; delete p; &#125;&#125;;#endif 四、测试 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&quot;mySharedPtr.h&quot;#include&quot;myUniquePtr.h&quot;#include&quot;debugDelete.h&quot;using std::cout;using std::cin;using std::endl;int main()&#123; // 测试 myUniquePtr &#123; myUniquePtr&lt;int&gt; up1(new int(42), debugDelete()); myUniquePtr&lt;int&gt; up2(new int(100)); cout &lt;&lt; &quot;Value in up1: &quot; &lt;&lt; *up1.get() &lt;&lt; endl; up2 = std::move(up1); // 移动赋值,此时up1被清空，但暂时不会销毁，作用域结束再销毁 cout &lt;&lt; &quot;Value in up2 after move: &quot; &lt;&lt; *up2.get() &lt;&lt; endl; &#125; // up1,up2 会在这里被销毁，DebugDelete 会被调用 // 测试 mySharedPtr &#123; mySharedPtr&lt;int&gt; sp1(new int(42)); mySharedPtr&lt;int&gt; sp2(sp1); // 拷贝构造 mySharedPtr&lt;int&gt; sp3(new int(100), debugDelete()); mySharedPtr&lt;int&gt; sp4=sp3; cout &lt;&lt; &quot;Value in sp1: &quot; &lt;&lt; *sp1.get() &lt;&lt; endl; cout &lt;&lt; &quot;Value in sp2: &quot; &lt;&lt; *sp2.get() &lt;&lt; endl; cout &lt;&lt; &quot;Value in sp3: &quot; &lt;&lt; *sp3.get() &lt;&lt; endl; cout &lt;&lt; &quot;Value in sp4: &quot; &lt;&lt; *sp4.get() &lt;&lt; endl; sp3 = sp1; // 赋值 cout &lt;&lt; &quot;Value in sp3 after assignment: &quot; &lt;&lt; *sp3.get() &lt;&lt; endl; &#125; // 都在这里被销毁，sp1,sp2,sp3默认删除器会被调用,sp4使用debug，sp3因为后续被赋值成sp1了，所以删除器被更改 //销毁顺序为栈，sp4-&gt;sp3-&gt;sp2-&gt;sp1 return 0;&#125; 输出： 1234567891011Value in up1: 42Value in up2 after move: 42debug deletedebug deleteValue in sp1: 42Value in sp2: 42Value in sp3: 100Value in sp4: 100Value in sp3 after assignment: 42 debug deletemySharedPtr default delete","tags":["C++"],"categories":["学习记录","C++Primer5th"]},{"title":"C++Primer5th 第十六章2","path":"/posts/11844.html","content":"实现智能指针 一、模板 1.定义 函数模板 函数模板允许定义一个通用的函数，它可以接受任意类型的参数。具体类型在函数调用时由编译器推导或指定。 类模板 类模板允许定义一个通用的类，它的成员函数和数据成员可以根据类型参数的不同而表现不同。 2.作用 泛型编程： 模板允许编写能够适应多种数据类型的代码，这减少了重复代码的编写。比如，你可以使用同一个 add 函数处理 int、double 或 float 类型的数据，而不需要为每种类型单独编写一个 add 函数。 代码复用： 模板能够极大地提高代码的复用性。通过模板，可以创建通用的容器（如 vector、list），算法（如 sort、swap）等，使用时只需要提供类型参数。 类型安全： 虽然模板提供泛型编程的能力，但在编译时会进行类型检查，因此模板代码仍然是类型安全的。编译器根据模板参数实例化具体的类型，并检查操作是否符合该类型的要求。 性能优化： 模板在编译时进行实例化，相比于运行时的多态机制（如虚函数），它能够带来更好的性能，因为函数和类模板是根据具体类型在编译时生成的。 3.注意点 当在模板类中定义友元模板函数时，因为在类中已经知道了模板实参，所以有的成员函数可以不需要指定模板参数 例如： 12345678910111213template&lt;typename T&gt; class Vec&#123;public: Vec():element(nullptr),first_free(nullptr),cap(nullptr)&#123;&#125; Vec(const Vec&amp;); Vec(Vec &amp;&amp;s) noexcept:element(s.element),first_free(s.first_free),cap(s.cap)&#123; s.element=s.cap=s.first_free=nullptr; &#125; Vec&amp; operator=(const Vec&amp;); Vec&amp; operator=(Vec &amp;&amp;) noexcept; friend bool operator== (const Vec&amp; lhs,const Vec&amp; rhs)；&#125;; 上面的构造函数声明中，可以不需要指定出Vec&lt;T&gt;,但是友元函数不指定的话，无法分辨是正常函数还是模板函数。 1friend bool operator== (const Vec&amp; lhs,const Vec&amp; rhs)；//无法判断 一般可以用两种方法 直接定义（更推荐） 在类里面直接定义出该友元函数的内容： 1234567friend bool operator== (const Vec&amp; lhs,const Vec&amp; rhs)&#123; if(lhs.size()!=rhs.size()) return false; for(size_t i=0;i&lt;lhs.size();i++)&#123; if(lhs[i]!=rhs[i]) return false; &#125; return true;&#125; 前向声明 12345678910111213template&lt;typename T&gt; class Vec;// 前向声明友元函数template&lt;typename T&gt;bool operator== (const Vec&lt;T&gt;&amp; lhs, const Vec&lt;T&gt;&amp; rhs);template&lt;typename T&gt;class Vec &#123; // 省略其他代码...public: // 声明友元模板函数 friend bool operator== &lt;&gt;(const Vec&lt;T&gt;&amp; lhs, const Vec&lt;T&gt;&amp; rhs);&#125;; 二、引用折叠 X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp;折叠成类型X&amp; 类型X&amp;&amp; &amp;&amp; 折叠成X&amp;&amp; 三、转发 假设我们需要写一个反转的模板函数，将两个变量转换位置输出 1234template &lt;typename F, typename T1, typename T2&gt;void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2) &#123; f(t2, t1); // 这里没有 std::forward&#125; 假如： 12int x = 42;flip([](int&amp;&amp; a, int&amp;&amp; b) &#123; /*...*/ &#125;, std::move(x), 100); T1 被推导为 int&amp;&amp;，因为我们使用了 std::move(x)（这是一个右值）。 T2 被推导为 int，因为 100 是一个右值。 但在 f(t2, t1) 这行代码中： t2 和 t1 是函数内部的变量，在调用 f 时，它们都是左值，即使它们的实际类型是右值引用或右值。 所以，在没有使用 std::forward 的情况下，传递给 f 的 t2 和 t1 都会被当作左值。 因此，即使 t1 本来是右值，它也会被当作左值传递给 f。如果 f 的参数期望右值引用（比如 int&amp;&amp;），这可能导致编译错误或不符合预期的行为。 为了保持传递的值类别（左值或右值），我们需要使用 std::forward： 1234template &lt;typename F, typename T1, typename T2&gt;void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2) &#123; f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1)); // 保留传递的值类别&#125; 四、可变参数模板 12template&lt;typename T,typename... Args&gt;void foo(const T &amp;t,const Args ...rest); Args为模板参数包，rest为函数参数包 1234template&lt;typename ... Args&gt; void g(Args ... args) &#123;\tcout &lt;&lt; sizeof...(Args) &lt;&lt; endl; // 模板参数包的数量\tcout &lt;&lt; sizeof...(args) &lt;&lt; endl; // 函数参数包的数量&#125;","tags":["C++"],"categories":["学习记录","C++Primer5th"]},{"title":"C++Primer5th 第十五章","path":"/posts/52290.html","content":"面向对象程序设计 一、概述 1.什么是类和对象 类 是对一组对象的抽象描述，而 对象 是类的实例。 以animal为例： 123456789class Animal &#123;private: double weight; double height;public: virtual void speak()&#123; //虚函数，支持重写 std::cout &lt;&lt; &quot;Animal sound&quot; &lt;&lt; std::endl; &#125;&#125;; 上述是个简单的animal类例子，在animal动物中，都会有身高体重属性，还有普遍的行为，也就是会叫speak 在动物类中，比如说狗，和猫，它们均是动物，是动物类下的分支，但猫和狗两大类又有不同 猫和狗都会继承动物类的属性和行为，均有身高体重属性，和都会叫 12345678910111213class Dog : public Animal &#123;public: void speak() override &#123; std::cout &lt;&lt; &quot;Woof!&quot; &lt;&lt; std::endl; &#125;&#125;;class Cat : public Animal &#123;public: void speak() override &#123; std::cout &lt;&lt; &quot;Meow!&quot; &lt;&lt; std::endl; &#125;&#125;; 但他们叫的方式不同，也就是同一个行为下的重写override 以上都是类，还是抽象的。 12Dog hask；//一个对象（实例），属于狗类，还属于动物大类，会狗叫Cat qq；//一个对象（实例），属于猫类，还属于动物大类，会猫叫 二、基类和派生类（继承） 在章节一中的例子中，基类就是Animal类，派生类就是Cat，Dog。 通过类派生列表来指定继承了哪些类，通常继承一个类，也可以继承多个类，比如体育老师可以继承体育类和老师类。 1class 体育老师 : public 体育,public 老师 &#123;&#125;； 1.继承类型 访问权限 public：公共成员可以被任何其他代码访问，包括类的外部代码和派生类。 protected：受保护成员只能被类的成员函数、友元函数和派生类的成员函数访问，但不能被类的外部代码访问。 private：私有成员只能被类的成员函数和友元函数访问，无法被外部代码或派生类的成员函数访问。 继承权限 public 继承：基类的 public 成员和 protected 成员在派生类中保持其访问权限，private 成员不可访问。 protected 继承：基类的 public 和 protected 成员在派生类中变为 protected，而 private 成员仍不可访问。 private 继承：基类的 public 和 protected 成员在派生类中变为 private，而 private 成员仍不可访问。 2.继承内容 非私有的成员变量（protected和public成员）。 非私有的成员函数（包括虚函数）。 静态成员变量和静态成员函数（非私有的）。 派生类不会继承构造函数、析构函数、私有成员、友元关系。 3.切片问题 切片主要发生在处理对象的复制时，尤其是当涉及到基类和派生类的对象时。切片指的是当一个派生类对象被赋值给基类对象时，派生类特有的数据和行为被丢弃，只保留基类部分。 123456789101112131415161718class Base &#123;public: virtual void show() const &#123; std::cout &lt;&lt; &quot;Base class&quot; &lt;&lt; std::endl; &#125;&#125;;class Derived : public Base &#123;public: void show() const override &#123; std::cout &lt;&lt; &quot;Derived class&quot; &lt;&lt; std::endl; &#125; void derivedMethod() const &#123; std::cout &lt;&lt; &quot;Derived method&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Derived d; // 创建派生类对象 Base b = d; // 发生切片 b.show(); // 输出 &quot;Base class&quot; // b.derivedMethod(); // 编译错误：b没有derivedMethod return 0;&#125; 在上面的例子中，当我们将 Derived 类型的对象 d 赋值给基类对象 b 时，d 的信息（如 derivedMethod）被切片掉，b 只保留 Base 部分。 三、虚函数 1.什么是虚函数 以Animal类为例，当派生类需要重写基类的某个函数时，可以将函数定义为虚函数，以此实现多态性。 关键字为virtual 1virtual void speak(); 而派生类可以定义同名函数实现不同内容通过override（可以不写，但最好写上） 1void speak() override; 2.注意点 基类通常都应该定义应该虚析构函数，即使不执行任何操作 虚函数可以与默认实参一起使用，但注意，如果在派生类中重写了函数，默认实参将以派生类的参数为准。 例如： 1234567891011121314151617181920class Base &#123;public: virtual void display(int x = 10) &#123; // 虚函数，带有默认实参 cout &lt;&lt; &quot;Base class: x = &quot; &lt;&lt; x &lt;&lt; endl; &#125;&#125;;class Derived : public Base &#123;public: void display(int x = 20) override &#123; // 派生类重写虚函数，并设置不同的默认实参 cout &lt;&lt; &quot;Derived class: x = &quot; &lt;&lt; x &lt;&lt; endl; &#125;&#125;;int main() &#123; Base* basePtr = new Derived(); // 基类指针指向派生类对象 basePtr-&gt;display(); // 调用的是Derived::display，但默认实参是Base类的 delete basePtr; return 0;&#125; 虚函数应在基类中定义，普通虚函数有默认实现，纯虚函数要求派生类实现。 纯虚函数一般形式： 1virtual 返回类型 函数名()=0； 四、动态绑定 1.定义 动态绑定（Dynamic Binding）是面向对象编程中实现多态性的重要机制。它允许程序在运行时根据对象的实际类型选择合适的函数实现，而不是在编译时决定。这种机制使得继承和虚函数的使用更加灵活。 例如： 12345678Animal* myDog = new Dog();Animal* myCat = new Cat();myDog-&gt;speak(); // 输出 &quot;Woof!&quot;myCat-&gt;speak(); // 输出 &quot;Meow!&quot;delete myDog; // 记得释放内存delete myCat; 上面的例子中，myDog 和 myCat 的 speak 方法调用是动态绑定的。 如果我们在 Animal 类中没有将 speak 声明为虚函数，那么即使使用基类指针，调用的也会是 Animal 类的 speak 方法，而不是派生类的实现。这就是动态绑定的好处。 2.静态绑定和动态绑定 静态绑定（Static Binding）：也叫早绑定，是在编译时根据变量的声明类型决定调用哪个函数。例如，普通的非虚函数就是静态绑定。 动态绑定（Dynamic Binding）：也叫晚绑定，是在运行时根据对象的实际类型决定调用哪个函数。虚函数的调用通过动态绑定实现。 3.实现条件 虚函数：函数必须在基类中被声明为virtual。 指针或引用：调用函数时，必须通过指向基类的指针或引用来实现。 派生类重写：派生类中必须重写基类的虚函数。 4.工作原理 C++通过虚函数表（vtable）实现动态绑定。当一个类包含虚函数时，编译器会为每个类维护一个虚函数表，表中记录了该类及其派生类所实现的所有虚函数的地址。每个对象还会有一个指向其所属类的虚函数表的指针，称为虚指针（vptr）。当通过基类指针调用虚函数时，程序会通过虚指针查找对象的实际类型，并从虚函数表中找到正确的函数实现。 五、其他 代码： 12345static bool compare(const std::shared_ptr&lt;Quote&gt;&amp; lhs, const std::shared_ptr&lt;Quote&gt;&amp; rhs) &#123; return lhs-&gt;isbn() &lt; rhs-&gt;isbn();&#125;std::multiset&lt;std::shared_ptr&lt;Quote&gt;, decltype(&amp;compare)&gt; items&#123;&amp;compare&#125;; 自定义比较函数 set，map这种需要自定义比较规则的时候，传入的应该是可调用的对象 例如新建类，或者类里面重构，并传入这个类。 如果是普通的函数，需要传入这个函数指针，并指名函数指针的类型，避免类型混淆（特别是在运用模板中），同时还需要在后面添加一个实例 而通过类的对象传参，则不需要在后面添加这个实例。 如果普通函数不添加这个实例，则容器在初始化构造的时候，调用的还是默认的比较函数，容器需要一个实例去初始化。 1234567struct compare &#123; bool operator()(const std::shared_ptr&lt;Quote&gt;&amp; lhs, const std::shared_ptr&lt;Quote&gt;&amp; rhs) const &#123; return lhs-&gt;isbn() &lt; rhs-&gt;isbn(); // 按 ISBN 排序 &#125;&#125;;std::multiset&lt;std::shared_ptr&lt;Quote&gt;,compare&gt; items； 上述例子就不需要指定函数指针，也不需要添加实例参数。","tags":["C++"],"categories":["学习记录","C++Primer5th"]},{"title":"C++Primer5th 第十四章","path":"/posts/3836.html","content":"重载运算与类型转换 一、运算符重载 基本概念 执行a+b其实是隐形执行了operator+(a,b),隐形调用了一个函数 a作为成员函数的时候执行运算符时，函数自带一个this指针，因此函数只需要一个参数 123456789StrVec&amp; StrVec::operator=(const StrVec&amp;s)&#123; if(&amp;s!=this)&#123; auto newdata=alloc_n_copy(s.begin(),s.end()); free(); element=newdata.first; first_free=newdata.second; &#125; return *this;&#125; 需要多个参数并且需要本身参数时。需要用到友元函数。例如： 123456friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;os,const StrVec &amp;s)&#123; for(size_t i=0;i&lt;s.size();i++)&#123; os&lt;&lt;s[i]&lt;&lt;&quot; &quot;; &#125; return os;&#125; 不能重构的运算符 :: .* . ?: 输入输出运算符 12345678910111213141516//重载&lt;&lt;std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os,const StrVec &amp;s)&#123; for(size_t i=0;i&lt;s.size();i++)&#123; os&lt;&lt;s[i]&lt;&lt;&quot; &quot;; &#125; return os;&#125;//重载&gt;&gt;std::istream &amp;operator&gt;&gt;(std::istream &amp;is, StrVec &amp;s)&#123; std::string t; is&gt;&gt;t; if(is) s.push_back(t); else s=StrVec(); return is;&#125; 相等运算符 1234567bool operator==(const StrVec&amp; lhs,const StrVec&amp; rhs)&#123; if(lhs.size()!=rhs.size()) return false; for(size_t i=0;i&lt;lhs.size();i++)&#123; if(lhs[i]!=rhs[i]) return false; &#125; return true;&#125; 赋值运算符 123456789StrVec&amp; StrVec::operator=(const StrVec&amp;s)&#123; if(&amp;s!=this)&#123; auto newdata=alloc_n_copy(s.begin(),s.end()); free(); element=newdata.first; first_free=newdata.second; &#125; return *this;&#125; 下标运算符 123456std::string&amp; operator[](size_t index) &#123; return element[index]; // 返回元素的引用&#125;const std::string&amp; operator[](size_t index) const &#123; return element[index]; // 返回元素的常量引用（用于 const 对象）&#125; 二、function库 function可以用来绑定函数： 123456789101112#include &lt;functional&gt;#include &lt;iostream&gt;void print(int x) &#123; std::cout &lt;&lt; x &lt;&lt; std::endl;&#125;int main() &#123; std::function&lt;void(int)&gt; func = print; func(5); // 输出 5 return 0;&#125; 三、类型转换 类型转换符 一般形式： 1operator type() const 例子： 123456789101112131415class SmallInt&#123;pubilc: SmallInt(int i=0): val(i)&#123; if(i&lt;0||i&gt;255) throw std::out_or_range(&quot;bad&quot;); &#125; operator int() cosnt &#123;return val;&#125;private: std::size_t val;&#125;;int main()&#123; Smallint si; si=4;//4被隐式转换成Smallint ,然后给构造函数 si+3;//si隐式转换成int&#125; explicit关键字 隐式类型转换有可能带来问题，因此c11引入了explicit关键字，可以避免隐式转换。 123Smallint si=3;si+3;//错误，声明了explicit后无法隐式转换static_cast&lt;int&gt;(si) +3;//正确 static_cast 在c中类型转换一般直接 （type）变量来达到类型转换 c++需要通过static_cast&lt;type&gt; 变量来执行类型转换。","tags":["C++"],"categories":["学习记录","C++Primer5th"]},{"title":"C++Primer5th 第十三章","path":"/posts/24637.html","content":"拷贝复制 1. 拷贝、赋值、销毁、移动构造、移动赋值（以StrVec为例） 析构函数： 1~StrVec(); 拷初构造函数： 1StrVec(const StrVec &amp;); 拷贝赋值函数： 1StrVec &amp;operator=(const StrVec&amp;); 移动构造函数: 1StrVec(StrVec &amp;&amp;s)noexcept; 移动赋值函数： 1StrVec &amp;operator=(StrVec &amp;&amp;) noexcept; 三法则 如果一个类定义了拷贝、赋值、销毁之一，通常也应该定义其余两个 五法则 五法则扩展了三法则，引入了移动语义。在 C++11 中，移动语义使得对象可以通过移动而不是拷贝来转移资源，从而提高效率。 如果一个类定义了以上五个之一，通常也应该定义其余的四个。 2. 左右值、引用 a. 引用内存占用 在编译器中如GCC,Clang，MSVC，引用本质其实就是个指针常量，所占空间和指针大小相同。但是现代编译器有优化操作。 例如： 123int a=10;int &amp;r=a;r=20; r作为a的引用，在某些编译器中可以优化为： 12int a=10;a=20; 编译器可以直接将 ref 替换为 a，而无需在内部生成任何指向 a 的指针。结果是，没有对 ref 进行额外的空间分配。 大多数情况下，例如在类里面有成员是引用对象，则必须得占用空间。 b. 左右值 左值（lvalue）： 左值是指可以在内存中持久存在的对象，具有可寻址性，通常是变量、数组元素等。 左值可以在赋值语句的左侧使用。例如：1int x = 5; // x 是一个左值 右值（rvalue）： 右值通常是临时对象、字面量或计算结果，不能直接取地址。 右值的生命周期通常是短暂的，往往只在表达式的上下文中存在。例如：1int y = x + 5; // x + 5 是一个右值 c. 引用 左值引用和右值引用在 C++ 中的大小通常是零，因为它们不占用任何额外的内存。它们的存在只是为了提供一种更方便的语法来访问对象。 左值引用（lvalue reference）： 左值引用（lvalue reference）通常在底层实现为一个指针。在使用左值引用时，编译器会将引用的对象的地址存储在内存中。 当你声明一个左值引用时，编译器实际上会在需要使用这个引用的地方生成代码，以获取原始对象的地址。 使用 &amp; 定义，能够绑定到左值。 左值引用允许对引用对象进行修改。例如：123int a = 10;int&amp; ref = a; // ref 是 a 的左值引用ref = 20; // a 的值现在是 20 右值引用（rvalue reference）： 右值引用（rvalue reference）也在底层实现为指针，但它们的使用语义与左值引用不同。右值引用允许对临时对象进行操作，并且通常与移动语义相关。 当你声明一个右值引用时，编译器会生成代码以允许对临时对象的移动（而不是拷贝）。 使用 &amp;&amp; 定义，能够绑定到右值。 右值引用主要用于实现移动语义，允许对临时对象进行高效处理，避免拷贝。例如：12void process(int&amp;&amp; value) &#123; /* 处理 value */ &#125;process(10); // 10 作为右值被传递 3. Message类 Message.h 1234567891011121314151617181920212223#ifndef MESSAGE_H#define MESSAGE_H#include &lt;set&gt;#include &lt;string&gt;class Folder;class Message &#123; friend class Folder;public: explicit Message(const std::string &amp;str = &quot;&quot;) : contents(str) &#123;&#125; Message(const Message&amp;); Message&amp; operator=(const Message&amp;); ~Message(); void save(Folder&amp;); void remove(Folder&amp;);private: std::string contents; std::set&lt;Folder*&gt; folders; void add_to_Folders(const Message&amp;); void remove_from_Folders(); void addFol( Folder *f) &#123; folders.insert(f); &#125; void remFol( Folder *f) &#123; folders.erase(f); &#125;&#125;;#endif // MESSAGE_H Message.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;Message.h&quot;#include &quot;Folder.h&quot;// 构造函数Message::Message(const Message &amp;m) : contents(m.contents), folders(m.folders) &#123; add_to_Folders(m);&#125;// 析构函数Message::~Message() &#123; remove_from_Folders();&#125;// 赋值运算符Message&amp; Message::operator=(const Message &amp;rhs) &#123; if (this != &amp;rhs) &#123; remove_from_Folders(); contents = rhs.contents; folders = rhs.folders; add_to_Folders(rhs); &#125; return *this;&#125;// 保存 Message 到 Foldervoid Message::save(Folder &amp;f) &#123; folders.insert(&amp;f); f.addMsg(this);&#125;// 从 Folder 中移除 Messagevoid Message::remove(Folder &amp;f) &#123; folders.erase(&amp;f); f.remMsg(this);&#125;// 辅助函数：将当前 Message 添加到所有关联的 Folder 中void Message::add_to_Folders(const Message &amp;m) &#123; for (auto f : m.folders) &#123; f-&gt;addMsg(this); &#125;&#125;// 辅助函数：将当前 Message 从所有关联的 Folder 中移除void Message::remove_from_Folders() &#123; for (auto f : folders) &#123; f-&gt;remMsg(this); &#125;&#125; Folder.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;Folder.h&quot;#include &quot;Message.h&quot;// 构造函数Folder::Folder(const Folder &amp;f) : msgs(f.msgs) &#123; add_to_Message(f);&#125;// 赋值运算符Folder&amp; Folder::operator=(const Folder &amp;rhs) &#123; if (this != &amp;rhs) &#123; remove_to_Message(); msgs = rhs.msgs; add_to_Message(rhs); &#125; return *this;&#125;// 析构函数Folder::~Folder() &#123; remove_to_Message();&#125;// 辅助函数：将当前 Folder 添加到 Message 中void Folder::add_to_Message(const Folder &amp;f) &#123; for (auto s : f.msgs) &#123; s-&gt;addFol(this); &#125;&#125;// 辅助函数：将当前 Folder 从 Message 中移除void Folder::remove_to_Message() &#123; for (auto m : msgs) &#123; m-&gt;remFol(this); &#125; msgs.clear();&#125;// 添加消息到 Foldervoid Folder::addMsg(Message *m) &#123; msgs.insert(m);&#125;// 从 Folder 中移除消息void Folder::remMsg(Message *m) &#123; msgs.erase(m);&#125; Folder.h 12345678910111213141516171819202122232425#ifndef FOLDER_H#define FOLDER_H#include &lt;set&gt;class Message;class Folder &#123; friend class Message;public: Folder() = default; Folder(const Folder&amp;); Folder&amp; operator=(const Folder&amp;); ~Folder();private: std::set&lt;Message*&gt; msgs; void add_to_Message(const Folder&amp;); void remove_to_Message(); void addMsg(Message *m); void remMsg(Message *m);&#125;;#endif // FOLDER_H 4. StrVec类 StrVec.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;vector&gt;#include&lt;string&gt;class StrVec&#123;public: StrVec():element(nullptr),first_free(nullptr),cap(nullptr)&#123;&#125; StrVec(const StrVec&amp;); StrVec(StrVec &amp;&amp;s) noexcept:element(s.element),first_free(s.first_free),cap(s.cap)&#123; s.element=s.cap=s.first_free=nullptr; &#125; StrVec &amp;operator=(const StrVec&amp;); StrVec &amp;operator=(StrVec &amp;&amp;) noexcept; std::string&amp; operator[](size_t index) &#123; return element[index]; // 返回元素的引用 &#125; const std::string&amp; operator[](size_t index) const &#123; return element[index]; // 返回元素的常量引用（用于 const 对象） &#125; StrVec(std::initializer_list&lt;std::string&gt; ilist); ~StrVec(); void push_back(const std::string&amp;); void push_back(std::string &amp;&amp;); void pop_back(); void reserve(size_t new_cap); void resize(size_t new_size)&#123;resize(new_size,&quot;&quot;);&#125; void resize(size_t new_size,const std::string &amp;value); size_t size() const &#123; return first_free-element;&#125; size_t capacity() const &#123; return cap-element; &#125; std::string *begin() const &#123; return element; &#125; std::string *back() const &#123;return first_free-1;&#125; std::string *end() const &#123; return first_free; &#125;private: void chk_n_alloc()&#123; if(size()==capacity()) reallocate(); &#125; std::pair&lt;std::string*,std::string*&gt; alloc_n_copy (const std::string*,const std::string*);//创造一片新内存并将原StrVec复制过去，并返回新首尾指针 void free(); void reallocate();//获得更多内存并拷贝已有的元素private: std::allocator&lt;std::string&gt; alloc; std::string *element;//头指针 std::string *first_free;//元素的尾指针 std::string *cap;//数组尾指针&#125;; StrVec.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &quot;StrVec.h&quot;void StrVec::push_back(const std::string &amp;s)&#123; chk_n_alloc(); alloc.construct(first_free++,s);&#125;void StrVec::push_back(std::string &amp;&amp;s)&#123; chk_n_alloc(); alloc.construct(first_free++,std::move(s));&#125;void StrVec::pop_back()&#123; if (first_free != element) &#123; // 确保不为空 alloc.destroy(--first_free); // 销毁最后一个有效元素 &#125;&#125;void StrVec::reserve(size_t new_cap)&#123; if(new_cap&lt;=capacity()) return; auto newdata=alloc.allocate(new_cap); auto dest=newdata; auto elem=element; for(auto i=0;i!=size();i++) alloc.construct(dest++,std::move(*elem++)); free(); element=newdata; first_free=dest; cap=element+new_cap;&#125;void StrVec::resize(size_t new_size,const std::string &amp;value)&#123; if(new_size&lt;size())&#123; for(auto p=element+new_size;p!=first_free;)&#123; alloc.destroy(--first_free); &#125; &#125;else if(new_size&gt;size())&#123; while (new_size&gt;capacity())&#123; reallocate(); &#125; for(auto i=size();i&lt;new_size;i++) push_back(value); &#125;&#125;void StrVec::free()&#123; if(element)&#123; for(auto p=first_free;p!=element;) alloc.destroy(--p); alloc.deallocate(element,cap-element); &#125;&#125;StrVec::StrVec(const StrVec&amp;s)&#123; auto newdata=alloc_n_copy(s.begin(),s.end()); element=newdata.first; first_free=newdata.second;&#125;StrVec::StrVec(std::initializer_list&lt;std::string&gt; ilist)&#123; auto newdata=alloc_n_copy(ilist.begin(),ilist.end()); element=newdata.first; first_free=cap=newdata.second;&#125;StrVec&amp; StrVec::operator=(const StrVec&amp;s)&#123; if(&amp;s!=this)&#123; auto newdata=alloc_n_copy(s.begin(),s.end()); free(); element=newdata.first; first_free=newdata.second; &#125; return *this;&#125;StrVec&amp; StrVec::operator=(StrVec &amp;&amp;rhs) noexcept&#123; if(&amp;rhs!=this)&#123; free(); element=rhs.element; first_free=rhs.first_free; cap=rhs.cap; &#125; return *this;&#125;StrVec::~StrVec()&#123; free();&#125;std::pair&lt;std::string*,std::string *&gt;StrVec::alloc_n_copy(const std::string *b,const std::string *e)&#123; auto data=alloc.allocate(e-b);//创建一个大小为（e-b）空间，首指针为data return &#123;data,uninitialized_copy(b,e,data)&#125;;//类似copy，将be中的内容复制构造到data之后，返回尾指针&#125;void StrVec::reallocate()&#123; auto newcapacity=size()?2*size():1;//如果为0则1，不为则*2 auto newdata = alloc.allocate(newcapacity); auto dest=newdata; auto elem=element;//旧头指针 for(auto i=0;i&lt;size();i++)&#123; alloc.construct(dest++,std::move(*elem++)); &#125; //移动元素版 // auto dest=uninitialized_copy(make_move_iterator(begin()),make_move_iterator(end()),newdata); free(); element=newdata; first_free=dest; cap=element+newcapacity;&#125;","tags":["C++"],"categories":["学习记录","C++Primer5th"]},{"title":"C++Primer5th 第十二章","path":"/posts/27716.html","content":"动态内存和智能指针 动态内存 内容 存放位置 作用域 全局变量和静态变量 数据段中，包含了已初始化的数据段和未初始化的数据段 全局变量整个程序，静态变量在文件或者函数有效 局部变量 存放在栈中， 在作用域中，离开作用域销毁 动态分配的内存 堆（heap）这个堆跟数据结构的堆不一样，相当于一片自由的空间，由程序员控制，new,delete,malloc,free 可跨域，由程序员自己销毁 函数 函数本身放在代码段,函数里面参数都放在栈中 看函数本身是局部还是全局 为什么需要动态内存 不知道存放多大的对象 不知道对象类型 为了在多个对象中共享数据 动态内存的问题 以往的动态内存中，由程序员建立和销毁动态内存，容易出现以下情况导致内存泄漏 一个指针指向了一个内存，换了一个指向之后，之前的内存找不到，未定义 一直未释放动态内存 内存相互引用 智能指针 share_ptr 可共享的指针，带有自动销毁对象的功能 unique_ptr 独享对象，有特殊功能realse释放对象 weak_ptr 不参与引用计数，经常用于打破循环引用 allocator类 allocate函数用于分配指定数量的未构造对象的内存，将构造和定义分离开。 c语言中的内存分布，malloc和free malloc只分布内存，示例： 123int *p=(int *)malloc(sizeof(int));*p=10;free(p)//释放 c++中的new，delete 示例： 12int*p=new int (10)；//分配一个int并初始化为10delete p;//释放p allocate 示例： 12345allocator&lt;int&gt;alloc;int *p=alloc.allocate(1);//分配不初始化alloc.construct(p,10);//手动调用构造函数，初始化为10alloc.destroy(p);//手动调用析构函数alloc.deallocate(p,1);//释放内存 文本查询程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;using line_id = vector&lt;string&gt;::size_type;class queryResult&#123; friend ostream &amp;print(ostream&amp; os , const queryResult &amp;qr)&#123; os&lt;&lt;qr.searchWord&lt;&lt;&quot; occurs&quot;&lt;&lt; qr.lines-&gt;size()&lt;&lt;&quot; &quot; &lt;&lt;(qr.lines-&gt;size()==1?&quot;time&quot;:&quot;times&quot;)&lt;&lt;endl; for(auto num: *qr.lines)&#123; os&lt;&lt;&quot;\\t(line &quot;&lt;&lt;num+1&lt;&lt;&quot; )&quot; &lt;&lt;*(qr.file-&gt;begin()+num)&lt;&lt;endl; &#125; return os; &#125;public: queryResult (string s,shared_ptr&lt;set&lt;line_id&gt;&gt; p, shared_ptr&lt;vector&lt;string&gt;&gt;f):searchWord(s),lines(p),file(f)&#123;&#125;private: string searchWord; shared_ptr&lt;set&lt;line_id&gt;&gt; lines; shared_ptr&lt;vector&lt;string&gt;&gt; file;&#125;;class textQuery &#123;public: textQuery(ifstream&amp; is): file(new vector&lt;string&gt;)&#123; string text; while (getline(is,text))&#123; file-&gt;push_back(text); int n=file-&gt;size()-1;//当前行号 istringstream line(text); string word; while (line&gt;&gt;word)&#123; auto &amp;ptr_set = mp[word]; if(!ptr_set) ptr_set.reset(new set&lt;line_id&gt;); else ptr_set-&gt;insert(n); &#125; ​ &#125;&#125;queryResult query(const string &amp;searchWord) const&#123;​ static shared_ptr&lt;set&lt;line_id&gt;&gt; nodata(new set&lt;line_id&gt;);​ auto loc = mp.find(searchWord);​ if(loc== mp.end()) ​ return queryResult(searchWord,nodata,file);​ else ​ return queryResult(searchWord,loc-&gt;second,file);&#125;private: shared_ptr&lt;vector&lt;string&gt;&gt; file; map&lt;string,shared_ptr&lt;set&lt;line_id&gt;&gt;&gt; mp;&#125;;void runQuery(ifstream &amp;infile)&#123; textQuery tq(infile); while(true)&#123; string word; cout&lt;&lt;&quot;enter word you want to query or &#x27;q&#x27; to quit: &quot;; if(!(cin&gt;&gt;word)||word[0]==&#x27;q&#x27;) break; print(cout,tq.query(word)); &#125;&#125;int main()&#123; string load=&quot;test.txt&quot;; ifstream in(load); if(in.is_open()) runQuery(in); else cout&lt;&lt;&quot;error in open file &quot;; return 0;&#125;","tags":["C++"],"categories":["学习记录","C++Primer5th"]},{"title":"C++Primer5th 第十一章","path":"/posts/43841.html","content":"关联容器 相关容器 有序关联容器 基于红黑树（red-black-tree）时间复杂度都在O(log n) map set multimap mulitset 无序关联容器 基于哈希表（hash）时间复杂度都在O(1),最坏为O(n) unordered_map unordered_set unordered_multimap unordered_multiset 知识点 类型别名 名字 内容 key_type 对应关键字 mapped_type 对应关键字映射的类型 value_type 对应存放的值，map为pair，set为key_type find和count的优劣 find是判断是否存在的最好方式，因为find找到就返回了 count则是需要全部遍历一遍 []下标方式 []通过该方式遇到一个未存在的key时，会自动插入一个map[key]=0 insert 和 [] insert pair 和 [],下标更新的map是最后一个value，而insert是第一个插入的key，value lower_bound和upper_bound 两者均返回一个指针，lower指向第一个大于等于val的值，upper指向第一个严格大于val的值 之所以叫lower和upper取自数学中的上下界 例如val=3 数组{1，2，3，3，3，5} 可知，3的下界为第一个3，上界为5,表示为[3,5]; 所以lower指向第一个3，upper指向大于3的5 map.erase() 关联容器中的删除函数，有特殊情况，例如在多重map和set中，erase(key),返回的是删除该key的个数","tags":["C++"],"categories":["学习记录","C++Primer5th"]},{"path":"/googlefdd717d7a8ffdcf3.html","content":"google-site-verification: googlefdd717d7a8ffdcf3.html"},{"title":"朋友文章","path":"/friends/rss/index.html","content":""}]